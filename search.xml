<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用Docker容器启动命令]]></title>
    <url>%2F2988032586.html</url>
    <content type="text"><![CDATA[数据库关系型数据库MySQL123docker run -p 3306:3306 --name mysql \ -v "$(pwd)/mysql/var":/var/lib/mysql \ -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 Postgres1234docker run --name postgres \ -v "$(pwd)/postgres":/var/lib/postgresql/data \ -e POSTGRES_PASSWORD=123456 \ -p 5432:5432 -d postgres PgAdmin123docker run -p 8080:80 --name=pgadmin \ -e "PGADMIN_DEFAULT_EMAIL=admin@zhaoqi.vip" \ -e "PGADMIN_DEFAULT_PASSWORD=123456" -d dpage/pgadmin4 时序数据库Prometheus123docker run -d --name=prometheus -p 9090:9090 \ -v $PWD/prometheus:/etc/prometheus \ prom/prometheus Influxdb12docker run -d -p 8086:8086 --name influxdb \ -v $PWD/influxdb:/var/lib/influxdb influxdb DevOps监控Cadvisor1234567docker run -d --volume=/:/rootfs:ro \ --volume=/var/run:/var/run:ro \ --volume=/sys:/sys:ro \ --volume=/var/lib/docker/:/var/lib/docker:ro \ --volume=/dev/disk/:/dev/disk:ro \ --publish=8080:8080 --detach=true --name=cadvisor \ google/cadvisor:latest Grafana123docker run -d -p 3000:3000 --name grafana \ -v $PWD/grafana:/var/lib/grafana \ -v $PWD/grafana/etc:/etc/grafana grafana/grafana GitGitlab12345docker run -d -p 8001:8001 -p 222:22 --name gitlab \ -v "$(pwd)/gitlab/config":/etc/gitlab \ -v "$(pwd)/gitlab/logs":/var/log/gitlab \ -v "$(pwd)/gitlab/data":/var/opt/gitlab \ --restart=always gitlab/gitlab-ce 工具测试hoppscotch(postwoman)1docker run -p 3000:3000 hoppscotch/hoppscotch:latest 其他LDAPldap12345678910docker run -d -p 389:389 \ -v $PWD/ldap/ldap:/var/lib/ldap \ -v $PWD/ldap/slapd.d:/etc/ldap/slapd.d \ --name ldap \ --env LDAP_TLS=false \ --env LDAP_ORGANISATION="zhaoqi" \ --env LDAP_DOMAIN="zhaoqi.vip" \ --env LDAP_ADMIN_PASSWORD="123456" \ --env LDAP_CONFIG_PASSWORD="123456" \ --restart=always osixia/openldap phpldapadmin123456docker run -dit -p 19999:80 \ --link ldap \ --name ldap_mgr \ --env PHPLDAPADMIN_HTTPS=false \ --env PHPLDAPADMIN_LDAP_HOSTS=ldap \ --restart=always osixia/phpldapadmin]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下编译Miracl密码库]]></title>
    <url>%2F2543483413.html</url>
    <content type="text"><![CDATA[介绍Miracl是一个密码学C语言函数库,网上针对Windows环境下使用的教程都是使用MSVC编译的,步骤比较繁琐,还需安装Visual Studio。看了一下官网文档,是支持使用gcc进行编译的,遂尝试了一下。 所需环境 CodeBlocks Git Bash 编译 从Github上下载项目最新源码。(下载地址) 打开Git Bash,创建一个文件夹miracl，并将压缩文件拷贝至此。mkdir miracl 打开Git Bash，输入如下命令，将所有文件解压到一个目录中。unzip -j -aa -L master.zip 编辑gcdoit.bat，注释掉最后几行并保存。 执行gcdoit.bat,生成的miracl.a即为编译好的库。 测试 打开CodeBlocks，新建Console application项目。 将mirdef.h、miracl.h、miracl.a拷贝至项目根目录。 对着CB左侧工作空间中的项目名右键，点击添加文件,将上述三个文件添加至项目中。 CB会弹出如下错误提示,莫慌. 对着CB左侧工作空间中的项目名右键,点击生成选项,修改链接器设置. 环境设置选择: 仅使用项目选项 在main.c中输入如下代码，进行测试。 1234567891011121314#include "miracl.h"int main() &#123; big x,y,z; miracl *mip = mirsys(1000, 16); x= mirvar(0); y= mirvar(0); z= mirvar(0); bigbits(100,x); bigbits(100,y); bigbits(100,z); add(x,y, z); cotnum(z,stdout); return 0;&#125; 点击CB中的生成并运行按钮，如图所示。 gcc编译命令为: 12gcc filename.c miracl.a -o filename./filename.exe 参考资料 树莓派下编译并使用miracl密码库 win10+gcc+miracl]]></content>
      <tags>
        <tag>Miracl</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker搭建Gitlab仓库]]></title>
    <url>%2F151510421.html</url>
    <content type="text"><![CDATA[安装 拉取Gitlab镜像docker pull gitlab/gitlab-ce 创建文件夹mkdir gitlab 创建容器 12345docker run -d -p 8001:8001 -p 222:22 --name gitlab \ -v "$(pwd)/gitlab/config":/etc/gitlab \ -v "$(pwd)/gitlab/logs":/var/log/gitlab \ -v "$(pwd)/gitlab/data":/var/opt/gitlab \ --restart=always gitlab/gitlab-ce 也可以将8001修改为其他端口 配置 修改配置文件vi gitlab/config/gitlab.rbexternal_url &#39;http://www.xxx.com:8001&#39; or external_url &#39;http://{ip}:8001&#39; 重启容器docker restart gitlab 使用 首次打开时需要设置管理员密码 查看Clone信息]]></content>
      <tags>
        <tag>Gitlab</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现一个迷你Shell]]></title>
    <url>%2F1118750159.html</url>
    <content type="text"><![CDATA[简介俄勒冈州立大学（Oregon State University) CS 344作业,使用C语言实现一个Shell. 要求 内置 cd,status和exit 命令 支持输入和输出的重定向 支持后台运行(&amp;) Ctrl-Z 与 Ctrl-C 调用系统其他命令 替换命令中的$$为Shell的PID 参考资料作业pdf 测试脚本p3testscriptview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/bin/bashecho "PRE-SCRIPT INFO"echo " Grading Script PID: $$"echo ' Note: your smallsh will report a different PID when evaluating $$'./smallsh &lt;&lt;'___EOF___'echo BEGINNING TEST SCRIPTechoecho --------------------echo Using comment (5 points if only next prompt is displayed next)#THIS COMMENT SHOULD DO NOTHINGechoechoecho --------------------echo ls (10 points for returning dir contents)lsechoechoecho --------------------echo ls out junkls &gt; junkechoechoecho --------------------echo cat junk (15 points for correctly returning contents of junk)cat junkechoechoecho --------------------echo wc in junk (15 points for returning correct numbers from wc)wc &lt; junkechoechoecho --------------------echo wc in junk out junk2; cat junk2 (10 points for returning correct numbers from wc)wc &lt; junk &gt; junk2cat junk2echoechoecho --------------------echo test -f badfile (10 points for returning error value of 1, note extraneous &amp;)test -f badfilestatus &amp;echoechoecho --------------------echo wc in badfile (10 points for returning text error)wc &lt; badfileechoechoecho --------------------echo badfile (10 points for returning text error)badfileechoechoecho --------------------echo sleep 100 background (10 points for returning process ID of sleeper)sleep 100 &amp;echoechoecho --------------------echo pkill -signal SIGTERM sleep (10 points for pid of killed process, 10 points for signal)echo (Ignore message about Operation Not Permitted)pkill sleepechoechoecho --------------------echo sleep 1 background (10 pts for pid of bg ps when done, 10 for exit value)sleep 1 &amp;sleep 1echoechoecho --------------------echo pwdpwdechoechoecho --------------------echo cdcdechoechoecho --------------------echo pwd (10 points for being in the HOME dir)pwdechoechoecho --------------------echo mkdir testdir$$mkdir testdir$$echoechoecho --------------------echo cd testdir$$cd testdir$$echoechoecho --------------------echo pwd (5 points for being in the newly created dir)pwdecho --------------------echo Testing foreground-only mode (20 points for entry &amp; exit text AND ~5 seconds between times)kill -SIGTSTP $$datesleep 5 &amp;datekill -SIGTSTP $$exit___EOF___ 源码smallsh.cview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/wait.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define MAX_INPUT_LENGTH 2048#define MAX_ARG_NUMBER 512#define SPLIT_CHAR " \t\r\n"int allowBg = 1;char *readLine(){ size_t maxLength = MAX_INPUT_LENGTH; char *line = (char *)malloc(sizeof(char) * maxLength); fgets(line, maxLength, stdin); int i = 0; for (i = 0; i &lt; maxLength; i++) { if (line[i] == '\n') { line[i] = '\0'; } } return line;}char **parse(char *line, int *num, int *back){ size_t maxNumber = MAX_ARG_NUMBER; int i = 0; char **arr = (char **)malloc(sizeof(char *) * maxNumber); char *token; token = strtok(line, SPLIT_CHAR); while (token != NULL) { arr[i] = token; // replace $$ int j = 0; for (j = 0; j &lt; strlen(arr[i])-1; j++) { if (arr[i][j] == '$' &amp;&amp; arr[i][j + 1] == '$') { arr[i][j] = '\0'; arr[i][j+1] = '\0'; char t[10]; char newArg[50]; memset(t, '\0', 10); memset(newArg, '\0', 50); strncpy(newArg, arr[i], j); sprintf(t, "%d", getpid()); strcat(newArg, t); // sprintf(arr[i], newArg); arr[i] = newArg; } } i++; token = strtok(NULL, SPLIT_CHAR); } if (i &gt;= 2 &amp;&amp; strcmp(arr[i - 1], "&amp;") == 0) { arr[i - 1] = NULL; i--; if(allowBg == 1){ *back = 1; } } *num = i; arr[i] = NULL; return arr;}void printStatus(int status){ if (status == 0 || status == 1) printf("exit value %d\n", status); else printf("terminated by signal %d\n", status);}void catchSIGTSTP(int sig){ if (allowBg == 1) { char *message = "Entering foreground-only mode(&amp; is now ignored)\n"; write(STDOUT_FILENO, message, 49); fflush(stdout); allowBg = 0; } else { char *message = "Exiting foreground-only mode\n"; write(STDOUT_FILENO, message, 30); fflush(stdout); allowBg = 1; }}void catchSIGINT(int signo){ char message[] = "terminated by signal "; char t[10]; memset(t, '\0', 10); sprintf(t, "%d", signo); strcat(message, t); strcat(message, "\n"); printf("%s", message); fflush(stdout); fflush(stdin);}int newProcess(char **arr, int num, int back){ pid_t pid = fork(); int status, fd; int input_flag = -1; int output_flag = -1; int i = 0; for (i = 0; i &lt; num; i++) { if (strcmp(arr[i], "&lt;") == 0) input_flag = i; else if (strcmp(arr[i], "&gt;") == 0) output_flag = i; } if (pid == 0) { struct sigaction sigint = {0}; sigint.sa_handler = catchSIGINT; sigemptyset(&amp;sigint.sa_mask); sigint.sa_flags = 0; sigaction(SIGINT, &amp;sigint, NULL); // input redirect if (input_flag &gt; -1) { fd = open(arr[input_flag + 1], O_RDONLY, 0644); if (fd == -1) { printf("cannot open %s for input\n", arr[input_flag + 1]); exit(1); } else { if (dup2(fd, 0) == -1) { printf(": Could not redirect stdin for input file %s\n", arr[input_flag + 1]); exit(1); } arr[input_flag] = NULL; close(fd); } } //output redirect if (output_flag &gt; -1) { fd = open(arr[output_flag + 1], O_WRONLY | O_CREAT | O_TRUNC, 0644); if (fd == -1) { printf("cannot not open %s for output\n", arr[output_flag + 1]); exit(1); } else { if (dup2(fd, 1) == -1) { printf("Could not redirect stdout for output file %s\n", arr[output_flag + 1]); exit(1); } arr[output_flag] = NULL; close(fd); } } if (back == 1 &amp;&amp; input_flag &lt; 0) { fd = open("/dev/null", O_RDONLY, 0644); if (fd == -1) { printf("Could not open \"/dev/null\"\n"); exit(1); } else { if (dup2(fd, 0) == -1) { printf("Could not redirect stdin to \"/dev/null\"\n"); exit(1); } close(fd); } } // printf("%c\n", arr[0][0]); if (execvp(arr[0], arr) == -1 &amp;&amp; arr[0][0] &gt;= 'a' &amp;&amp; arr[0][0] &lt;= 'z') { printf("%s: no such file or directory\n", arr[0]); fflush(stdout); exit(1); } } else if (pid &lt; 0) { printf("Smallsh !\n"); return 1; } else { // parent if (back == 1) { printf("Background pid is %d.\n", pid); fflush(stdout); } else { waitpid(pid, &amp;status, WUNTRACED); if (WIFEXITED(status)) return (WEXITSTATUS(status)); else if (WIFSIGNALED(status)) return (WTERMSIG(status)); } } return status;}int executeCommand(char **arr, int status, int num, int back){ if (arr[0] == NULL || strcmp("#", arr[0]) == 0) return status; else if (strcmp(arr[0], "exit") == 0) exit(0); else if (strcmp(arr[0], "status") == 0) printStatus(status); else if (strcmp(arr[0], "cd") == 0) { char *directory; if (arr[1] == NULL) directory = getenv("HOME"); else directory = arr[1]; if (chdir(directory) == -1) { printf("cd: No such file or directory\n"); fflush(stdout); } return status; } else { int t = newProcess(arr, num, back); // printf("------------%d---\n",t); // fflush(stdout); return t; }}int main(){ char *input; char **arr; int status = 0; struct sigaction sigint = {0}; sigint.sa_handler = SIG_IGN; sigemptyset(&amp;sigint.sa_mask); sigint.sa_flags = 0; sigaction(SIGINT, &amp;sigint, NULL); struct sigaction sigtstp = {0}; sigtstp.sa_handler = catchSIGTSTP; sigfillset(&amp;sigtstp.sa_mask); sigtstp.sa_flags = 0; sigaction(SIGTSTP, &amp;sigtstp, NULL); while (1) { int num = 0; int back = 0; printf(": "); fflush(stdout); input = readLine(); arr = parse(input, &amp;num, &amp;back); status = executeCommand(arr, status, num, back); //background pid_t childPid = waitpid(-1, &amp;status, WNOHANG); if (childPid &gt; 0) { printf("background pid %d is done: ", childPid); if (WIFEXITED(status)) printf("exit value %d\n", WEXITSTATUS(status)); else printf("terminated by signal %d\n", status); fflush(stdout); } fflush(stdin); free(input); free(arr); } return 0;} 总结wait()函数12pid_t wait(int* status);pid_t waitpid(pid_t pid, int* status, int options); WNOHANG 如果该子进程没有结束，则以非阻塞方式等待子进程，并且返回0;如果该子进程已经结束，返回其pid.如果没有子进程退出，则立刻返回-1 WUNTRACED 若子进程进入暂停状态，则马上返回 WIFEXTED与WEXITSTATUS WIFEXTED(status) 这个宏用来获取是否正常退出，正常退出获得true WEXITSTATUS(status) 只可在WIFEXITED为true时使用，获取正常退出的状态码 WIFSIGNALED与WTERMSIG WIFSIGNALED(status) 这个宏用来获取是否异常退出，异常退出获得true WTERMSIG(status) 只可在WIFSIGNALED为true时使用，获取异常退出的状态码smallsh.cview raw12345waitpid(pid, &amp;status, WUNTRACED); if (WIFEXITED(status)) return (WEXITSTATUS(status)); else if (WIFSIGNALED(status)) return (WTERMSIG(status));]]></content>
      <tags>
        <tag>Shell</tag>
        <tag>C语言</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Django中间件处对API进行统一处理]]></title>
    <url>%2F2620614917.html</url>
    <content type="text"><![CDATA[前言公司实习时遇到一个问题:项目中所使用不是Restful API,每个视图函数都要先生成字典，于是项目中便充斥着如下的代码:123456result=&#123; "msg":'xx", "status":200, "result":data&#125;return HttpResponse(json.loads(result)) 维护起来比较麻烦，对前端也很不友好，为了解决该问题，自定义了一个Django中间件对API格式和异常进行统一处理，以此达到如下效果: 在view中只需返回data，raise自定义的异常 实现自定义异常状态码(status)和自定义异常信息(message) view中返回的Object若为Model,则会返回调用其__str__方法的结果 对于view中出现的其他异常，Response会返回Unknown exception 异常信息(message)实现了i18n Django中对异常的处理Django中对request的处理 首先执行process_request函数，然后在执行视图函数之前执行process_view函数，再执行视图函数，最后执行process_response函数 process_request只返回None，所有中间件的process_request执行完之后，就匹配路由，找到对应的视图函数，在执行视图函数之前先执行中间件的 process_view函数 如果process_view返回 None，就继续执行后续的中间件的process_view方法，执行完所有的process_view函数之后执行视图函数 如果其中有个 process_view 返回了 HttpResponse，就不执行后续的 process_view 函数，会跳到第一个 process_response 函数，并继续往下执行 中间件(类)中5种方法中间件中可以定义5个方法: process_request(request) process_view(request, view_func, view_args, view_kwargs) process_exception(request, exception) process_template_response(request, response) process_response(request, response) process_request 中间件在收到request请求之后执行 按照settings.py中MIDDLEWARE_CLASSES的顺序，顺序执行 如果该函数返回None，继续执行后面的中间件的process_request方法 如果该函数返回HttpResponse，则不再继续执行后面的中间件的process_request方法 process_view 执行完所有中间件的process_request方法 在urls.py中找到对应视图函数 拿到视图函数的名称、参数，在执行视图函数之前执行 如果返回None，则继续执行后面的中间件的process_view函数，然后执行下昂应的视图函数 如果返回HttpResponse，则不执行后续的process_view函数，也不执行视图函数，然后执行所有的response中间件 process_exception 执行视图函数的过程中如果引发异常，则按照settings.py中MIDDLEWARE_CLASSES的顺序，倒序执行process_exception方法 如果返回None，继续执行下一个中间件的process_exception方法 如果返回HttpReponse对象，则该中间件上方其他中间件的process_exception方法不会被调用 一旦其中某个中间件有返回值，则调用template_response和response中间件,否则启动默认的异常处理 最后半句个人理解:如果如果所有中间件的process_exception方法都执完后还没有返回值，则启动默认的异常处理 process_template_response 在视图函数执行结束之后执行 response是Django视图或者某一中间件的返回值(TemplateResponse对象或等价) 只有response实现了render方法才会执行 一旦所有的中间件的template_response被执行完，则调用render方法 按照中间件的顺序，倒序执行 process_response 在视图函数执行结束之后执行 必须有返回值，且返回类型必须是HttpResponse对象 按照中间件的顺序，倒序执行 代码实现文件 middleware.py 123456789101112131415161718192021222324from django.utils.deprecation import MiddlewareMixinfrom django.models import modelsfrom django.core.serializers.json import DjangoJSONEncoderfrom django.http import JsonResponseclass MyMiddleware(MiddlewareMixin): def process_exception(self, request, exception): if not isinstance(exception, BaseException): if settings.DEBUG: return JsonResponse(&#123;'result': '', 'msg': str(exception), 'status': 1000&#125;) else: return JsonResponse(UnknownException().as_dict()) else: return JsonResponse(exception.as_dict()) def process_response(self, request, response): procese_type = (list, tuple, dict, str, int) if isinstance(response, models.Model): response = str(response) if isinstance(response, procese_type): ret = &#123;'result': response, 'msg': 'success', 'status': 200&#125; return JsonResponse(ret, encoder=DjangoJSONEncoder) else: return response exceptions.py 12345678910111213141516171819202122from abc import ABCMetafrom .message import ErrorMsgclass InterFaceAsDictInterFace: def as_dict(self): ret = &#123;'result': '', 'msg': getattr(self, '__msg__', ''), 'status': getattr(self, '__status__', '')&#125; return retclass BaseException(Exception, InterFaceAsDictInterFace): __metaclass__ = ABCMeta def __init__(self, msg=None): super(BaseException, self).__init__() if msg is not None: self.__msg__ = msgclass UnknownException(InterFaceAsDictInterFace): __status__ = 1000 __msg__ = ErrorMsg.UNKNOWN_EXCEPTIONclass MyException(BaseException): __status__=1001 __msg__=ErrorMsg.MY_EXCEPTION message.py 1234from django.utils.translation import gettext as _class ErrorMsg: UNKNOWN_EXCEPTION= _('Unknown exception.') MY_EXCEPTION = _('Test exception.') 修改settings文件修改setting中的MIDDLEWARE_CLASSES变量12345678910MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'middleware.MyMiddleware',] Todo对前端Post请求进行参数校验目前想出来了两种策略(假设post_json为序列化后的字典): 视图函数中使用get从字典中获取参数，判断required的参数是否为空，raise自定义的异常，如: 1234567891011121314151617181920212223# exception.py...class ValidationError(BaseException): __msg__ = ErrorMsg.INVALID_ARGUMENT __status__ = 1001...# message.pyclass ErrorMsg: UNKNOWN_EXCEPTION= _('Unknown exception.') INVALID_ARGUMENT = _('Invalid arguments.') REQUIRED_ARGUMENT = _('A &#123;0&#125; argument is required.')# view.pydef test(request): ... user_name = post_json.get('username','')# required pass_word = post_json.get('password','')# required user_type = post_json.get('user_type','')# not required if not username or not password: raise ValidationError(ErrorMsg.REQUIRED_ARGUMENT.format('username/passswordd')) ... 视图函数中对参数不做校验，只需在中间件添加一句，即可对视图函数中raise的KeyError进行统一处理 1234567891011121314151617181920212223242526# exception.py...class ValidationError(BaseException): __msg__ = ErrorMsg.INVALID_ARGUMENT __status__ = 1001...# middleware.py...def process_exception(self, request, exception): if isinstance(exception, KeyError): exception = ValidationError(ErrorMsg.REQUIRED_ARGUMENT.format(exception)) ...# message.pyclass ErrorMsg: UNKNOWN_EXCEPTION= _('Unknown exception.') INVALID_ARGUMENT = _('Invalid arguments.') REQUIRED_ARGUMENT = _('A &#123;0&#125; argument is required.')# view.pydef test(request): ... user_name = post_json['user_name'] # required user_type = post_json.get('user_type','')# not required ... 视图函数返回目前视图函数必须有返回值，不能为None，还不知道怎么解决 参考文献 Django 中间件官方文档 Django 国际化官方文档 Github项目(django-exceptionbox) 错误码设计以及 Django 的异常统一处理 Django—-中间件详解]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>API</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生苦短，我用Python]]></title>
    <url>%2F2604890615.html</url>
    <content type="text"><![CDATA[前言前几日代写留学生作业时遇到了两道很有意思的Python编程题，在此做一记录，主要涉及到一些Python的高级特性:生成器、lambda表达式。 Question 1题意原文:Consider the following functionCode12345678910# listOfNumbers is a list of only numbers#def processList(listOfNumbers): result = [] for i in listOfNumbers: if i&lt;0 == 0: result.append(ii) else: result.append((ii)+1) return result First, study and test processList(listOfNumbers) to determine what it does Then rewrite its body so that it accomplishes the same task with a one-line list comprehension. Thus, the resulting function will have exactly two lines, the def line and a return line containing a list comprehension expression.翻译:将给出的一个函数变成两行 分析函数的功能是:遍历listofNumbers中的每一个元素，如果大于等于0，将其变成自己乘以自己，否则变为自己乘自己后再加一。因此，我们可以用到Python中的三元表达式，下面这两种方式是等价的。value = true if condition else false与Code1234if condition: value = trueelse: value = false 参考答案Code12def processList(listOfNumbers): return [i i if i &gt;= 0 else i i + 1 for i in listOfNumbers] Question 2题意原文:Implement function processList2(inputList, specialItem, ignoreItems) that returns a new list that contains all the items of inputList (and in the original order) except 1) any that appear in the list ignoreItems, and 2) occurrences of specialItem (if specialItem is not in ignoreItems) should become the string “special” in the new list. Use a one-line list cluoomprehension to construct the new list. Thus, again, the function will have exactly two lines, the def line and a return line containing a list comprehension expression. For example, processList2([1,2,3,4], 4, [3])[1, 2, ‘special’]processList2([1,2,3,4,True,’dog’], 4, [3,5,4])[1, 2, True, ‘dog’]processList2([1,1,2,2], 1, [2])[‘special’, ‘special’] 翻译:实现函数processList2(inputList, specialItem, ignoreItems)，对inputList中的元素进行处理，返回一个新列表，但需满足以下两个要求: 不能是出现在ignoreItems中的元素 对于与specialItem相同的元素(不能在ignoreItems中出现)，将其变成”special”。 分析 首先将不在ignoreItems中的那些元素筛出来[x for x in inputList if x not in ignoreItems]或list(filter(lambda x:False if x in ignoreItems else True,inputList))。 然后遍历上述列表中的元素，将specialItem变成”special”,[&quot;special&quot; if x == specialItem else x for x in xxx] 参考答案Code1234def processList2(inputList, specialItem, ignoreItems): ## two method return [“special” if x == specialItem else x for x in list(filter(lambda x:False if x in ignoreItems else True,inputList))] return[“special” if x == specialItem else x for x in [x for x in inputList if x not in ignoreItems]] 参考资料 filter() 函数 列表生成式]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkServer RD650安装Ubuntu Server 16.04]]></title>
    <url>%2F560540611.html</url>
    <content type="text"><![CDATA[准备工作 在Ubuntu官网上下载Ubuntu Server 16.04的ISO镜像(下载链接)； 使用刻录软件(如:软碟通)将iso镜像文件写入U盘中，制成启动盘； 将ISO镜像文件拷贝至U盘的根目录，为了方便后续操作，这里可将镜像文件重命名为Ubuntu.iso； 设置引导 按电源键开机，启动服务器(服务器启动可能会比较缓慢)； 出现此界面时，按”F10”进入TDM(ThinkServer Deployment Manager)； 进入TDM后，选择”BIOS Setup(BIOS 设置)”； 选择”Boot Manager(引导管理)”,将”Boot Mode(引导模式)”改为”UEFI Only(仅UEFI模式)”； 点击”Save &amp; Reset(保存 &amp; 重启)”,在弹出的对话框中选择”Yes(是)”重启电脑。如果出现如下对话框，选择”No(否)”； 开始安装 将U盘插入服务器后的USB插槽中，重启服务器，进入下图所示界面。选择”Install Ubuntu Server(安装Ubuntu服务器版)”；注:若无法进入下图所示界面，请进入BIOS修改U盘为第一启动项。 选择安装过程和系统的默认语言为”English(英语)”； “Select your location(选择你的区域)”，这里选择”Other(其他)”； “Continent or region(大陆或地区)”选择”Asia(亚洲)”； “Country(国家)”选择”China(中国)”； 是否通过一系列的按键检测键盘布局，选择”NO(否)”； 字符集编码选择”United States -en_US.UTF-8”； “Country or Region for the keyboard(键盘布局所属国家或地区)”,选择”English(US)”； “Keyboard layout(键盘布局)”，选择”English(US)”； 稍等片刻，将会显示出现错误,原因为:安装程序未检测到CD-ROM。是否重试，选择”No(否)”； 进入如下界面，选择”Execute a shell(运行shell)”； 在shell中依次输入如下命令:123456ls /dev/sd*umount /dev/sdb4/mkdir udevmount /dev/sdb4 /udevmount /udev/ubuntu.iso /cdromexit 一般会出现两个/dev/sdb*项，我们选择带数字的那一项去替换上面代码中的/dev/sdb4;ubuntu.iso为U盘中Ubuntu Server的ISO镜像的文件名”。 进入如下界面后，选择”Detect and mount CD-ROM(探测并挂载光盘)”； 进入如下界面，选择”Network interface(网络接口)”，这里选择第一个网络接口，等待安装程序自动完成配置； 设置”Hostname(主机名)”； 设置”Full name for the new user(新用户的全名)”； 设置”Username for your account(你账号的用户名)”； 设置”password for the new user(新用户的密码)”； 如果所设置的密码较为简单，可能会弹出如下对话框，询问你是否使用一个”weak password(弱口令)”，选择”Yes(是)”； 出现如下界面，询问你是否”Encrypt your home directory(加密你的主目录)”； 然后可能会出现时区设置错误，选择 “Continue(继续)”,进入如下界面，选择”Install the system(安装系统)”,然后直接回车，选择”Partion disks(磁盘分区)”； 出现下图界面，询问你是否”Umount partitions that are in use(卸载正在使用的分区)”，选择”Yes(是)”； 选择”Partitioning method(分区方法)”，这里我们选择”Guided - use entire disk and set up LVM(使用整个磁盘并配置LVM)”； “Select disk to partition(选择要分区的磁盘)”； 选择”Partitioning Scheme(分区方案) “，这里推荐选择”All files in one partition(所有文件放在同一分区)”； 出现如下界面，询问你是否”Write the changes to disks and configure LVM(将修改写入磁盘并配置LVM)”； 设置”Name of the volume group for the new system(新系统的卷组名)”； 设置”Amount of volume group to use for guided partitioning(用于分区引导的卷组数)”，默认大小即可，无需修改； 出现下图界面，询问你是否”Umount partitions that are in use(卸载正在使用的分区)”，选择”Yes(是)”； 出现如下界面，询问你是否”Force UEFI installation(强制UEFI安装)”，选择”Yes(是)”； 出现如下界面，询问是否”Write the changes to disks(将改动写入磁盘)”，选择”Yes(是)”； “Kernel to install(要安装的内核)”,选择默认的”Linux-generic”即可； 回车后出现如下界面，这里要选择包含在initrd中的驱动程序，选择默认的”generic:include all available drivers(通用:包含所有可用的驱动程序)”即可； “HTTP proxy information(HTTP代理信息)”不写，直接回车即可； 询问你管理系统更新的方式，选择”No automatic updates(不自动更新)”； “Choose software to install(选择要安装的软件)”，建议勾选上”OpenSSh server”，然后回车;选择方法为:通过键盘上下键移动光标至选要择项，在要选择的项上按空格即可； 回车后，显示安装完成，继续回车，重启系统，此时就可以拔掉U盘； 重启后，再次进入TDM，将”Boot Mode(引导模式)”改为”Legacy Only(仅Legacy模式)”，否则有可能出现不能进入Linux系统的情况；]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用C#爬虫爬取校园最新通知]]></title>
    <url>%2F976598171.html</url>
    <content type="text"><![CDATA[前言前几个月用Python写了一个爬虫，用于爬取校园最新通知。最近的C#课程设计中想实现同样的功能，于是按照之前Python代码的思路重构了一下。用Python实现校园通知更新提醒 思路使用C#中的HttpWebRequest库去获取目标url(各个网站的’更多通知’页)的源代码，然后使用System.Text.RegularExpressions;进行正则匹配。正则表达式应包含三个分组:日期、标题、链接； 准备工作 命名空间导入123using System.Net;using System.Collections;using System.Text.RegularExpressions; 源代码Spider基类:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Spider&#123; private string url = string.Empty;//要爬取的网页的url public HttpWebRequest request; public HttpWebResponse response; public string encode = "UTF-8";//目标url的网页编码格式 public string Method = string.Empty; public string Url &#123; get &#123; return url; &#125; set &#123; url = value; &#125; &#125; public string Encode &#123; get &#123; return encode; &#125; set &#123; if (value == "UTF-8" || value == "GBK") &#123; encode = value; &#125; else &#123; //Todo:handle exception &#125; &#125; &#125; public Spider(string url,string method) &#123; this.url = url; this.Method = method; Create(); &#125; public Spider() &#123; &#125; public void Create() &#123; request = (HttpWebRequest)WebRequest.Create(url); request.Method = Method; request.Credentials = CredentialCache.DefaultCredentials; request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36"; &#125; //获取目标url的Html代码 public string getHtml() &#123; string reader = string.Empty; try &#123; Create(); response = (HttpWebResponse)request.GetResponse(); if (response.StatusCode == HttpStatusCode.OK) &#123; StreamReader sr = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding(encode)); reader = sr.ReadToEnd(); sr.Close(); response.Close();//关闭response响应流 &#125; else throw new Exception(); &#125; catch(Exception e) &#123; Log.Write( e.Message, "Exception"); MessageBox.Show(e.Message, "错误", MessageBoxButtons.OK, MessageBoxIcon.Error); &#125; return reader; &#125;&#125; SpiderNotice类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class SpiderNotice : Spider&#123; private string url_main;//各个通知链接的公共部分 private string department;//所属部门 private string type;//通知类型 private string pattern;//用于匹配的正则表达式规则 private ArrayList all_notice = new ArrayList();//所有的通知 public string parse = string.Empty;//日期的解析规则 public SpiderNotice(string url, string pattern, string url_main, string department, string type) : base(url, "GET") &#123; this.department = department; this.pattern = pattern; this.url_main = url_main; this.type = type; this.parse = "yyyy-MM-dd"; &#125; public void Get() &#123; all_notice.Clear(); Regex r = new Regex(pattern, RegexOptions.ExplicitCapture); try &#123; string s = getHtml(); if (s == null) throw new ArgumentNullException("html"); MatchCollection mc = r.Matches(s); foreach (Match m in mc) &#123; GroupCollection group = m.Groups; DateTime date = DateTime.ParseExact(group["date"].Value, parse, System.Globalization.CultureInfo.InstalledUICulture); string link = url_main + group["link"].Value; Notice n = new Notice(); n.Title = group["title"].Value; n.Link = link; n.Date = date; n.Department = department; n.Type = type; all_notice.Add(n); &#125; &#125; catch (Exception e) &#123; BLL.Log.Write(e.Message, "Exception"); MessageBox.Show(e.Message, "错误", MessageBoxButtons.OK, MessageBoxIcon.Error); &#125; &#125; public Notice index(int index) &#123; if (index &gt;= all_notice.Count) throw new IndexOutOfRangeException(); else return all_notice[index] as Notice; &#125; public Notice[] GetAll() &#123; Notice[] All = new Notice[all_notice.Count]; int flag = 0; foreach (object t in all_notice) &#123; All[flag++] = t as Notice; &#125; return All; &#125; public int Count() &#123; return all_notice.Count; &#125;&#125; 数据模型Notice类:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Notice&#123; #region 数据模型 private string title=string.Empty; private string link=string.Empty; private DateTime date=DateTime.Now; private string type=string.Empty; private string department=string.Empty; public string Title &#123; get &#123; return title; &#125; set &#123; title = value; &#125; &#125; public DateTime Date &#123; get &#123; return date; &#125; set &#123; date = value; &#125; &#125; public string Link &#123; set &#123; link = value; &#125; get &#123; return link; &#125; &#125; public string Type &#123; get &#123; return type; &#125; set &#123; type = value; &#125; &#125; public string Department &#123; get &#123; return department; &#125; set &#123; department = value; &#125; &#125; #endregion override public string ToString() &#123; return string.Format("标题:&#123;0&#125;\n时间:&#123;1&#125;\n链接:&#123;2&#125;\n", title, date.ToString("yyyy-MM-dd"), link); &#125;&#125; 问题总结 从不同网站上爬取到的日期格式可能不同，为统一格式，可以使用｀DateTime.ParseExact(datastr, parse, System.Globalization.CultureInfo.InstalledUICulture);｀去解析用于表示日期的字符串，然后再转为统一日期格式的字符串。其中，datastr为表示日期的字符串，parse为解析规则。例: 123string parse="yyyy-M-D";DateTime t=DateTime.ParseExact("2016-9-5", parse, System.Globalization.CultureInfo.InstalledUICulture);string str=t.toString("yyyy-MM-dd");//2016-09-05 不用网页的网页编码格式可能不同，有的为GBK,有的问UTF-8; 用字符串去表达正则表达式的规则时，有两种方法: string s=@”\d+”””;字符串前加@表示字符串按常量解析(注意:双引号用两个双引号来表示) string s=”\d+\””;使用转义符]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中使用SmtpClient发送邮件]]></title>
    <url>%2F3123403799.html</url>
    <content type="text"><![CDATA[最近写C#课程设计时需要用C#来发送邮件，但是网上搜的代码经过测试均不能使用，调试了很久也没能成功。最后索性自己对着官方文档撸了一个，期间踩了很多坑，故在此做一总结。 准备工作 命名空间导入:using System.Net.Mail; 在邮箱设置中开通smtp服务，并获取授权码。 源代码1234567891011121314151617181920212223242526272829303132333435363738string mailfrom, password, fromwho, host, mailto, subject, body;mailfrom = "xxx@qq.com";//发件人int port = 25;//端口号一般为25password = "**********";//邮箱密码host = "smtp.xxx.com";//主机地址fromwho = "xxx";//发件人的签名mailto = "xxx@qq.com";//收件人(多个收件人之间以英文逗号间隔)subject = "test";//邮件主题body = "xxxxx";//邮件正文SmtpClient smtp;smtp = new SmtpClient(host, port);smtp.UseDefaultCredentials = false;smtp.EnableSsl = true;//是否使用SSL加密连接smtp.DeliveryMethod = SmtpDeliveryMethod.Network;//指定邮件发送方式smtp.Credentials = new System.Net.NetworkCredential(mailfrom, password); //设置用于验证发件人身份的凭证string[] address = mailto.Split(',');//收件人地址列表MailMessage msg = new MailMessage();//邮件信息msg.From = new MailAddress(mailfrom, fromwho, Encoding.UTF8);msg.Subject = subject;//邮件标题msg.SubjectEncoding = Encoding.UTF8;msg.Body = body;//邮件正文msg.BodyEncoding = Encoding.UTF8;for (int i = 0; i &lt; address.Length; i++) msg.To.Add(address[i]);msg.Priority = MailPriority.Normal;//邮件优先级(High,Low,Normal)try&#123; smtp.Send(msg); Console.WriteLine("发送成功!");&#125;catch (Exception e)&#123; Console.WriteLine(e.Message);&#125;msg.Dispose(); 注意 代码中所使用的密码不是邮箱密码，应在邮箱设置中获取smtp服务授权码。 使用163邮箱时只能使用25端口(465/994不可用),EnableSsl属性设置为false/true 使用QQ邮箱发送时只能使用25端口(465/587不可用),且EnableSsl属性必须设置为true 代码使用QQ邮箱、163邮箱实测有效，其他邮箱尚不清楚 总结无论是QQ邮箱还是163邮箱，使用SSL端口发送时均出现异常：操作超时，查了好久，发现是因为:System.Net.Mail只支持显式SSL(Explicit SSL)，但是不支持隐式SSL(Implicit SSL)，QQ邮箱使用的应该是Implicit SSL。此问题似乎可以用System.Web.Mail或Cdosys.dll解决，但是还没有试过。关于QQ邮箱使用25端口发送时，必须使用设置SSL为true的原因:服务器从不受保护的25端口响应请求，然后将连接抛到受保护的465端口.显式SSL通过25端口连接 - &gt; StartTLS（开始加密）- &gt;验证 - &gt;发送数据隐式SSLStartSSL（开始加密） - &gt; 连接 - &gt; 验证 - &gt;发送数据 参考博客C#发送邮件三种方法，Localhost，SMTP，SSL-SMTPSystem.Net.Mail with SSL to authenticate against port 465You cannot use System.Net.Mail.SmtpClient to send an e-mail message with Implicit SSL]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用c#中的HttpWebRequest实现12306余票查询]]></title>
    <url>%2F1797370495.html</url>
    <content type="text"><![CDATA[准备工作 下载用于解析JSON的类库(Newtonsoft.Json.dll)(下载地址:Newtonsoft.Json.dll)； 在C#项目中添加对其的引用。 在程序中导入命名空间:12345using Newtonsoft.Json;using Newtonsoft.Json.Linq;using System.Net;using System.Text.RegularExpressions;using System.Xml; 思路API地址在浏览器中打开12306主页，点击余票查询，并使用浏览器中的开发者工具，进行抓包。这里，我们查询的是2018.06.25的上海至长沙的车票信息。此时浏览器发送请求的地址为：https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=2018-06-25&amp;leftTicketDTO.from_station=SHH&amp;leftTicketDTO.to_station=CSQ&amp;purpose_codes=ADULT由此,我们不难分析出API地址为：12string url="https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=&#123;0&#125;&amp;leftTicketDTO.from_station=&#123;1&#125;&amp;leftTicketDTO.to_station=&#123;2&#125;&amp;purpose_codes=&#123;3&#125;";url=string.Format(url,date,from,to,id); 其中，date代表出发日(格式为yyyy-MM-dd),from代表出发站的代码，to代表到达站的代码，id代表车票类型(成人为ADULT,学生为OX00); 车站代码车站对应的代码可在此下载:https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9055我们可以使用正则表达式从中提取出关键信息，并保存在一个XML文档中，便于以后的使用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public static void StationNameXml() &#123; string nowpath = Environment.CurrentDirectory; if (Directory.Exists(nowpath+"/Data")==false) Directory.CreateDirectory(nowpath + "/Data");//创建新路径 if (File.Exists(nowpath + "/Data/StationName.xml") == true) return;HttpWebRequest request; HttpWebResponse response; string url=@"https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9055"; request = (HttpWebRequest)WebRequest.Create(url); request.Method = "GET"; request.Credentials = CredentialCache.DefaultCredentials; request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36"; string str = string.Empty; try &#123; response = (HttpWebResponse)request.GetResponse(); if (response.StatusCode == HttpStatusCode.OK) &#123; StreamReader sr = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding("UTF-8")); str = sr.ReadToEnd(); sr.Close(); response.Close();//关闭response响应流 &#125; else throw new Exception(); &#125; catch(Exception e) &#123; Console.WriteLine(e.Message); &#125; string pattern = @"@\S&#123;2,5&#125;?[|](?&lt;Name&gt;\S&#123;1,8&#125;?)[|](?&lt;Code&gt;\S&#123;3,5&#125;?)[|]"; Regex r = new Regex(pattern, RegexOptions.ExplicitCapture); XmlDocument xmldoc = new XmlDocument(); XmlDeclaration xmldecl; xmldecl = xmldoc.CreateXmlDeclaration("1.0", "UTF-8", null);//加入XML的声明段落 xmldoc.AppendChild(xmldecl); XmlElement root = xmldoc.CreateElement("", "Dict", "");//加入一个根元素 xmldoc.AppendChild(root); MatchCollection mc = r.Matches(str); foreach (Match m in mc) &#123; GroupCollection group = m.Groups; XmlNode node = xmldoc.CreateNode(XmlNodeType.Element, "Pair", null); XmlNode temp = xmldoc.CreateNode(XmlNodeType.Element, "Station", null); temp.InnerText = group["Name"].Value; node.AppendChild(temp); XmlNode temp2 = xmldoc.CreateNode(XmlNodeType.Element, "Code", null); temp2.InnerText = group["Code"].Value; node.AppendChild(temp2); root.AppendChild(node); &#125; xmldoc.Save(nowpath+"/Data/"+"StationName.xml"); &#125; 依据中文车站名获取对应车站代码的方法为:1234567891011121314151617private static string StationCode(string StationName)&#123; XmlDocument doc = new XmlDocument(); doc.Load(Environment.CurrentDirectory + "/Data/StationName.xml"); XmlNodeList data = doc.DocumentElement.ChildNodes; foreach (XmlNode node in data) &#123; XmlElement xe = (XmlElement)node; XmlNodeList xnl0 = xe.ChildNodes; string s = xnl0.Item(0).InnerText; if(s==StationName) &#123; return xnl0.Item(1).InnerText; &#125; &#125; return string.Empty;&#125; 数据模型为了存储查询结果，我们需要构建一个车票的数据模型，具体如下；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public class Ticket &#123; #region 数据模型 private string trainid=string.Empty;//车次 private string fromstation = "--";//出发站 private string totation = "--";//到达站 private string ticketdate = string.Empty;//车票日期 private string starttime = "--";//发车时间 private string arrivetime = "--";//到达时间 private string lastedtime = "--";//历时 private string tzNum = "--";//特等座 private string ydNum = "--";//一等座 private string edNum = "--";//二等座 private string grwNum = "--";//高级软卧 private string rwNum = "--";//软卧 private string dwNum = "--";//动卧 private string ywNum = "--";//硬卧 private string rzNum = "--";//软座 private string yzNum = "--";//硬座 private string wzNum = "--";//无座 private string qtNum = "--";//其他 private string identity = string.Empty;//车票类型(学生/成人) public string TrainId &#123; get &#123; return trainid; &#125; set &#123; trainid = value; &#125; &#125; public string FromStation &#123; get &#123; return fromstation; &#125; set &#123; fromstation = value; &#125; &#125; public string ToStation &#123; get &#123; return totation; &#125; set &#123; totation = value; &#125; &#125; public string TicketDate &#123; get &#123; return ticketdate; &#125; set &#123; ticketdate = value; &#125; &#125; public string StartTime &#123; get &#123; return starttime; &#125; set &#123; starttime = value; &#125; &#125; public string ArriveTime &#123; get &#123; return arrivetime; &#125;set &#123; arrivetime = value; &#125; &#125; public string LastedTime &#123; get &#123; return lastedtime; &#125; set &#123; lastedtime = value; &#125; &#125; public string TzNum &#123; get &#123; return tzNum; &#125; set &#123; tzNum = value; &#125; &#125; public string YdNum &#123; get &#123; return ydNum; &#125; set &#123; ydNum = value; &#125; &#125; public string EdNum &#123; get &#123; return edNum; &#125; set &#123; edNum = value; &#125; &#125; public string GrwNum &#123; get &#123; return grwNum; &#125; set &#123; grwNum = value; &#125; &#125; public string RwNum &#123; get &#123; return rwNum; &#125; set &#123; rwNum = value; &#125; &#125; public string DwNum &#123; get &#123; return dwNum; &#125; set &#123; dwNum = value; &#125; &#125; public string YwNum &#123;get&#123; return ywNum; &#125;set&#123; ywNum = value; &#125; &#125; public string RzNum &#123;get&#123; return rzNum; &#125;set&#123; rzNum = value; &#125; &#125; public string YzNum &#123;get&#123; return yzNum; &#125;set&#123; yzNum = value; &#125; &#125; public string WzNum &#123;get&#123; return wzNum; &#125;set&#123; wzNum = value; &#125; &#125; public string QtNum &#123;get&#123; return qtNum; &#125;set&#123; qtNum = value; &#125; &#125; public string Identity &#123; get &#123; return identity; &#125;set &#123; identity = value; &#125; &#125; #endregion public Ticket() &#123; &#125; public Dictionary&lt;string, string&gt; getMap() &#123; Dictionary&lt;string, string&gt; result = new Dictionary&lt;string, string&gt;(); result.Add("车次", trainid); result.Add("出发站", FromStation); result.Add("到达站", ToStation); result.Add("发车时间", StartTime); result.Add("到达时间", ArriveTime); result.Add("历时", LastedTime); result.Add("特等座", TzNum); result.Add("一等座", YdNum); result.Add("二等座", EdNum); result.Add("高级软卧", GrwNum); result.Add("软卧", RwNum); result.Add("动卧", DwNum); result.Add("硬卧", YwNum); result.Add("软座", RzNum); result.Add("硬座", YzNum); result.Add("无座", WzNum); result.Add("其他", QtNum); return result; &#125;&#125; 解析JSON返回的报文为一个JSON格式的字符串，里面包含有各类车票信息、发车时间以及历时，为了对其进行解析，我们需要下载一个用于解析JSON的类库(下载地址:Newtonsoft.Json.dll)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private static Ticket[] SpiderTicket(string date, string from, string to, string id) &#123; HttpWebRequest request; HttpWebResponse response; string url = "https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=&#123;0&#125;&amp;leftTicketDTO.from_station=&#123;1&#125;&amp;leftTicketDTO.to_station=&#123;2&#125;&amp;purpose_codes=&#123;3&#125;"; url = string.Format(url, date, from, to, id); request = (HttpWebRequest)WebRequest.Create(url); request.Method = "GET"; request.Credentials = CredentialCache.DefaultCredentials; request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36"; string str = string.Empty; try &#123; response = (HttpWebResponse)request.GetResponse(); if (response.StatusCode == HttpStatusCode.OK) &#123; StreamReader sr = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding("UTF-8")); str = sr.ReadToEnd(); sr.Close(); response.Close();//关闭response响应流 &#125; else throw new Exception(); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; Dictionary&lt;string, string&gt; map=new Dictionary&lt;string, string&gt;();//保存返回的JSON串中的车站代码与车站名之间的映 ArrayList AllTicket = new ArrayList();//所有的车票信息 JObject jo = (JObject)JsonConvert.DeserializeObject(str); JToken record = jo["data"]["map"]; foreach (JProperty item in record) &#123; map.Add(item.Name.ToString(), item.Value.ToString()); &#125; record = jo["data"]["result"]; foreach (string s in record) &#123; string[] result = s.Split('|'); Ticket t = new Ticket(); t.TrainId = result[3]; t.FromStation = map[result[6]]; t.ToStation = map[result[7]]; t.StartTime = result[8]; t.ArriveTime = result[9]; t.LastedTime = result[10]; t.TicketDate = result[13]; t.DwNum = result[33] != "" ? result[33] : t.DwNum; t.TzNum = result[32] != "" ? result[32] : t.TzNum; t.YdNum = result[31] != "" ? result[31] : t.YdNum; t.EdNum = result[30] != "" ? result[30] : t.EdNum; t.YzNum = result[29] != "" ? result[29] : t.YzNum; t.YwNum = result[28] != "" ? result[28] : t.YwNum; t.WzNum = result[26] != "" ? result[26] : t.WzNum; t.RzNum = result[24] != "" ? result[24] : t.RzNum; t.RwNum = result[23] != "" ? result[23] : t.RwNum; t.GrwNum = result[21] != "" ? result[21] : t.GrwNum; AllTicket.Add(t); &#125; Ticket[] All = new Ticket[AllTicket.Count]; int flag = 0; foreach (object t in AllTicket) &#123; All[flag++] = t as Ticket; &#125; return All; &#125; 效果图项目地址:EasyLife 参考博客C#调用12306API做余票查询(该参考博客中的方法已不可用) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194using Newtonsoft.Json;using Newtonsoft.Json.Linq;using System;using System.Collections;using System.Collections.Generic;using System.IO;using System.Net;using System.Text;using System.Text.RegularExpressions;using System.Xml;namespace Ticket&#123; class Program &#123; public static void StationNameXml() &#123; string nowpath = Environment.CurrentDirectory; if (Directory.Exists(nowpath + "/Data") == false) Directory.CreateDirectory(nowpath + "/Data");//创建新路径 if (File.Exists(nowpath + "/Data/StationName.xml") == true) return; HttpWebRequest request; HttpWebResponse response; string url = @"https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9055"; request = (HttpWebRequest)WebRequest.Create(url); request.Method = "GET"; request.Credentials = CredentialCache.DefaultCredentials; request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36"; string str = string.Empty; try &#123; response = (HttpWebResponse)request.GetResponse(); if (response.StatusCode == HttpStatusCode.OK) &#123; StreamReader sr = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding("UTF-8")); str = sr.ReadToEnd(); sr.Close(); response.Close();//关闭response响应流 &#125; else throw new Exception(); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; string pattern = @"@\S&#123;2,5&#125;?[|](?&lt;Name&gt;\S&#123;1,8&#125;?)[|](?&lt;Code&gt;\S&#123;3,5&#125;?)[|]"; Regex r = new Regex(pattern, RegexOptions.ExplicitCapture); XmlDocument xmldoc = new XmlDocument(); XmlDeclaration xmldecl; xmldecl = xmldoc.CreateXmlDeclaration("1.0", "UTF-8", null);//加入XML的声明段落 xmldoc.AppendChild(xmldecl); XmlElement root = xmldoc.CreateElement("", "Dict", "");//加入一个根元素 xmldoc.AppendChild(root); MatchCollection mc = r.Matches(str); foreach (Match m in mc) &#123; GroupCollection group = m.Groups; XmlNode node = xmldoc.CreateNode(XmlNodeType.Element, "Pair", null); XmlNode temp = xmldoc.CreateNode(XmlNodeType.Element, "Station", null); temp.InnerText = group["Name"].Value; node.AppendChild(temp); XmlNode temp2 = xmldoc.CreateNode(XmlNodeType.Element, "Code", null); temp2.InnerText = group["Code"].Value; node.AppendChild(temp2); root.AppendChild(node); &#125; xmldoc.Save(nowpath + "/Data/" + "StationName.xml"); &#125; private static string StationCode(string StationName) &#123; XmlDocument doc = new XmlDocument(); doc.Load(Environment.CurrentDirectory + "/Data/StationName.xml"); XmlNodeList data = doc.DocumentElement.ChildNodes; foreach (XmlNode node in data) &#123; XmlElement xe = (XmlElement)node; XmlNodeList xnl0 = xe.ChildNodes; string s = xnl0.Item(0).InnerText; if (s == StationName) &#123; return xnl0.Item(1).InnerText; &#125; &#125; return string.Empty; &#125; private static Ticket[] SpiderTicket(string date, string from, string to, string id) &#123; HttpWebRequest request; HttpWebResponse response; string url = "https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=&#123;0&#125;&amp;leftTicketDTO.from_station=&#123;1&#125;&amp;leftTicketDTO.to_station=&#123;2&#125;&amp;purpose_codes=&#123;3&#125;"; url = string.Format(url, date, from, to, id); request = (HttpWebRequest)WebRequest.Create(url); request.Method = "GET"; request.Credentials = CredentialCache.DefaultCredentials; request.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36"; string str = string.Empty; try &#123; response = (HttpWebResponse)request.GetResponse(); if (response.StatusCode == HttpStatusCode.OK) &#123; StreamReader sr = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding("UTF-8")); str = sr.ReadToEnd(); sr.Close(); response.Close();//关闭response响应流 &#125; else throw new Exception(); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; Dictionary&lt;string, string&gt; map=new Dictionary&lt;string, string&gt;();//保存返回的JSON串中的车站代码与车站名之间的映 ArrayList AllTicket = new ArrayList();//所有的车票信息 JObject jo = (JObject)JsonConvert.DeserializeObject(str); JToken record = jo["data"]["map"]; foreach (JProperty item in record) &#123; map.Add(item.Name.ToString(), item.Value.ToString()); &#125; record = jo["data"]["result"]; foreach (string s in record) &#123; string[] result = s.Split('|'); Ticket t = new Ticket(); t.TrainId = result[3]; t.FromStation = map[result[6]]; t.ToStation = map[result[7]]; t.StartTime = result[8]; t.ArriveTime = result[9]; t.LastedTime = result[10]; t.TicketDate = result[13]; t.DwNum = result[33] != "" ? result[33] : t.DwNum; t.TzNum = result[32] != "" ? result[32] : t.TzNum; t.YdNum = result[31] != "" ? result[31] : t.YdNum; t.EdNum = result[30] != "" ? result[30] : t.EdNum; t.YzNum = result[29] != "" ? result[29] : t.YzNum; t.YwNum = result[28] != "" ? result[28] : t.YwNum; t.WzNum = result[26] != "" ? result[26] : t.WzNum; t.RzNum = result[24] != "" ? result[24] : t.RzNum; t.RwNum = result[23] != "" ? result[23] : t.RwNum; t.GrwNum = result[21] != "" ? result[21] : t.GrwNum; AllTicket.Add(t); &#125; Ticket[] All = new Ticket[AllTicket.Count]; int flag = 0; foreach (object t in AllTicket) &#123; All[flag++] = t as Ticket; &#125; return All; &#125; static void Main(string[] args) &#123; StationNameXml(); string from = "上海"; string to = "北京"; Ticket[] All=new Ticket[50]; All=SpiderTicket(DateTime.Now.ToString("yyyy-MM-dd"), StationCode(from), StationCode(to), "ADULT"); for(int i=0;i&lt;All.Length;i++) &#123; Dictionary&lt;string, string&gt; map = new Dictionary&lt;string, string&gt;(); map = All[i].getMap(); foreach (object j in map.Keys) Console.Write(j.ToString()+":"+map[j.ToString()].ToString()+" "); Console.WriteLine(); &#125; Console.Read(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中自己生成验证码]]></title>
    <url>%2F1000607951.html</url>
    <content type="text"><![CDATA[前言最近写C#课程设计时，登录验证处需用到验证码，于是参照网上博客，自己封装了一个验证码类，和网上其他博客相比，有以下优点: 去除了0,o,O与1,l等容易混淆的字符 使用方便，仅需三行代码 内置有返回MD5加密后的字符串的方法，便于前端调用 函数说明公有方法 SecurityCode(int length);//构造函数 SecurityCode(int length, int width, int height);//构造函数 void UpdateVerifyCode();//刷新验证码 Bitmap getImage();//返回验证码图片 string MD5Encrypt();//返回经MD5加密过的验证码字符串 bool Check(string text);//返回校验结果(不区分大小写) 私有方法 void CreateVerificationText(int length);//随机生成验证码字符串 void CreateImage();//生成验证码图片 Color RandColor();//生成随机颜色 Point RandPoint();//生成随机点 使用示例123SecurityCode Code=new SecurityCode(4);code.UpdateVerifyCode();picturebox.Image=code.getImage(); 效果图 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111class SecurityCode&#123; private Random rand = new Random();//生成随机数 private string VerificationText = string.Empty;//验证码字符串 private Bitmap map;//验证码的位图 private int length;//验证码的字符个数 private int width;//验证码图片的宽度 private int height;//验证码图片的高度 public SecurityCode(int length, int width, int height) &#123; this.length = length; this.width = width; this.height = height; &#125; public SecurityCode(int length) &#123; this.length = length; this.width = (length + 1) * 25; this.height = 40; &#125; //随机生成验证码字符串 private void CreateVerificationText(int length) &#123; VerificationText = string.Empty; string dictionary = "ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789";//去除O,o,0 ,l,1 for (int i = 0; i &lt; length; i++) &#123; int index = rand.Next(0, dictionary.Length); VerificationText += dictionary[index].ToString(); &#125; &#125; //刷新验证码 public void UpdateVerifyCode() &#123; CreateVerificationText(length); CreateImage(); //Console.WriteLine(MD5Encrypt(VerificationText));//Only for test &#125; //生成验证码图片 private void CreateImage() &#123; map = new Bitmap(width, height); Graphics g = Graphics.FromImage(map); Pen pen = new Pen(Color.Black); string[] font = &#123; "Verdana", "Microsoft Sans Serif", "Consolas", "Arial", "宋体" &#125;; Font f = new Font("Arial", 20, FontStyle.Bold); g.Clear(Color.White); SolidBrush brush = new SolidBrush(Color.White); //绘制干扰线条 pen.Width = 0.1F; for (int i = 0; i &lt; 15; i++) &#123; pen.Color = RandColor(); g.DrawLine(pen, RandPoint(), RandPoint()); &#125; //绘制干扰点 for (int i = 0; i &lt; 80; i++) &#123; Point p = RandPoint(); map.SetPixel(p.X, p.Y, RandColor()); &#125; //绘制字符串 SizeF StringSizeF = g.MeasureString(VerificationText, f); PointF StartPoint = new Point(0, (height - (int)StringSizeF.Height) / 2); for (int i = 0; i &lt; length; i++) &#123; brush.Color = RandColor(); int index = rand.Next(5); f = new Font(font[index], 20, FontStyle.Bold); StartPoint.X += 5; g.DrawString(VerificationText[i].ToString(), f, brush, StartPoint); SizeF CharSizeF = g.MeasureString(VerificationText[i].ToString(), f); StartPoint.X += CharSizeF.Width; &#125; g.Dispose(); &#125; //生成随机颜色 private Color RandColor() &#123; Color c = Color.FromArgb(rand.Next(1, 256), rand.Next(1, 255), rand.Next(1, 255)); return c; &#125; //生成随机点 private Point RandPoint() &#123; int x = rand.Next(0, map.Width); int y = rand.Next(0, map.Height); return new Point(x, y); &#125; //返回验证码图片 public Bitmap getImage() &#123; return map; &#125; //返回经MD5加密过的验证码字符串 public string MD5Encrypt() &#123; return Tool.MD5Encrypt(VerificationText); &#125; //返回校验结果 public bool Check(string text) &#123; return text.ToUpper().Equals(VerificationText.ToUpper());//不区分大小写 &#125;&#125;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行家算法(使用DFS找出所有安全序列)]]></title>
    <url>%2F647653334.html</url>
    <content type="text"><![CDATA[背景银行家算法银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。 安全状态 系统能按某种进程推进顺序{P1，…，Pn}为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。 此时称{P1，…，Pn}为安全序列。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。 并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，就有可能进入死锁状态。反之，只要系统处于安全状态，系统便不会进入死锁状态。 因此，避免死锁的实质在于，系统在进行资源分配时，应用系统不进入不安全状态。数据结构 可利用资源向量Available是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。 最大需求矩阵Max这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。 分配矩阵Allocation这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的数目为K。 需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。Need[i,j]=Max[i,j]-Allocation[i,j] 银行家算法设Requesti是进程Pi的请求向量，如果Requesti[j]=K,表示进程Pi需要K个Rj类型。当Pi发出资源请求后，系统按下输步骤进行检查: 如果Requesti[j] &lt;= Need[i][j],便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值 如果Requesti[j] &lt;= Available[i][j]，便转向步骤3；否则表示尚无足够资源，Pi需等待 系统试探着把资源分配给进程Pi,并修改下面数据结构中的数值: Available[j] -= Requesti[j] Allocation[i][j] += Requesti[j] Need[i][j] -= Requesti[j] 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态.若安全，正式将资源分配给进程Pi，以完成本次分配；否则，讲将本次的试探分配作废,恢复原来的资源分配状态，让进程Pi等待 12345678910bool check_bank(int i, int Request[]) //按照银行家算法检查资源请求&#123; for(int j = 0; j &lt; m; j++) &#123; if(Request[j] &gt; Need[i][j] || Request[j] &gt; Available[j]) return false; &#125; update(i, Request); return true;&#125; 尝试分配资源/恢复原来的资源分配状态尝试分配资源123456789void update(int i, int Request[]) //更新数据&#123; for(int j = 0; j &lt; m; j++) &#123; Available[j] -= Request[j]; Allocation[i][j] += Request[j]; Need[i][j] -= Request[j]; &#125;&#125; 恢复原来的资源分配状态123456789void recovery(int i, int Request[])//还原数据&#123; for(int j = 0; j &lt; m; j++) &#123; Available[j] += Request[j]; Allocation[i][j] -= Request[j]; Need[i][j] += Request[j]; &#125;&#125; 安全性算法 设置两个工作向量:① 工作向量WORK，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，WORK:=Available② Finish:它表示系统是否有足够的资源分配给进程，使之运行完成。初始Finish[i]: = false；当有足够资源分配给进程时，再令Finish[i]：=true。 从进程集合中找出一个满足下列条件的进程：① Finish[i] = false② Need[i][j] &lt;= work[j]若找到，执行3,否则，执行步骤4 当进程pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行: Finish[i] = true WORK[j] += Allocation[i][j] go to step 2 如果所有进程的Finish[i] = true，则表示系统处于安全性状态，否则，系统处于不安全状态。 12345678910111213int check_safe(int i, int Request[]) //检查系统安全性&#123; int Work[MaxNumber]; bool Finished[MaxNumber]; memset(Finished, false, sizeof(Finished)); for(int i = 0; i &lt; m; i++) Work[i] = Available[i]; sta = UnSafe; Dfs(0, Work, Finished); if(sta==UnSafe) recovery(i, Request);//还原数据 return sta;&#125; 复杂度分析:安全性检查算法，有两种for循环，最内层for循环每次继续向下一层搜索，故时间复杂度为O((n * m)^ n) 利用Dfs找出所有安全序列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void Dfs(int i, int Work[], bool Finished[])//深度优先搜索,找到所有的安全序列&#123; if(i == n) &#123; for(int j = 0; j &lt; n; j++) &#123; if(Finished[j] == false) &#123; return ; &#125; &#125; sta = Safe; SafeOrder.push_back(temp); //temp.clear(); return; &#125; for(int j = 0; j &lt; n; j++) &#123; if(Finished[j] == false) &#123; bool t = true; for(int k = 0; k &lt; m; k++) &#123; if(Need[j][k] &gt; Work[k]) &#123; t = false; break; &#125; &#125; if(t == true) &#123; for(int k = 0; k &lt; m; k++) Work[k] += Allocation[j][k]; Finished[j] = true; temp.push_back(j); Dfs(i + 1, Work, Finished); temp.pop_back(); //回溯,将第i个进程所做的改变恢复 for(int k = 0; k &lt; m; k++) &#123; Work[k] -= Allocation[j][k]; &#125; Finished[j] = false; &#125; &#125; &#125; return ;&#125; 测试数据3A 3B 3C 257 5 33 2 29 0 22 2 24 3 30 1 02 0 03 0 22 1 10 0 221102 实验截图 合理且安全的资源请求不合理的资源请求会导致系统处于不安全状态的资源请求 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299/*Problem:银行家算法Author:QiZhaoData:2018-05-31Description:预防进程死锁的银行家算法Copyright 2018 QiZhao. All rights reserved.*/#include&lt;iostream&gt;#include&lt;vector&gt;//提供vector#include&lt;cstring&gt;//提供memset函数#include&lt;cstdio&gt;//提供fflush函数#include&lt;cstdlib&gt;//提供exit函数using namespace std;enum status &#123;Safe, UnSafe&#125;;//安全性检查的结果const int MaxNumber = 100;//进程数量的最大值int Available[MaxNumber];//每种资源的可用数量int Max[MaxNumber][MaxNumber];//n*m的矩阵,表示每个进程所需的最大资源量string name[MaxNumber];//n个进程的进程名int Allocation[MaxNumber][MaxNumber];//n*m的矩阵,表示每个进程每种资源已经分配的量int Need[MaxNumber][MaxNumber];//n*m的矩阵,表示每个进程还需的每种资源量int Request[MaxNumber];//所请求的每种资源的资源量vector&lt;vector&lt;int&gt; &gt; SafeOrder;//存储所有的安全序列vector&lt;int&gt; temp;//存储一个临时安全序列int n, m;//进程数，资源种类数status sta = UnSafe;//安全性检查的结果//函数声明void input();void init();void show();void update(int i, int Request[]);void recovery(int i, int Request[]);bool check_bank(int i, int Request[]);int check_safe(int i, int Request[]);void request();void choose();void Dfs(int i,int Wordk[],bool Finished[]);void menu();//函数实现void input()//读入数据&#123; cout &lt;&lt; "请输入系统资源的种类数:"; cin &gt;&gt; m; cout &lt;&lt; "请依次输入" &lt;&lt; m &lt;&lt; "种系统资源的名称与数量:" &lt;&lt; endl; for(int i = 0; i &lt; m; i++) cin &gt;&gt; name[i] &gt;&gt; Available[i]; cout &lt;&lt; "请输入进程的数量:"; cin &gt;&gt; n; cout &lt;&lt; "请输入各个进程的最大需求量&lt;" &lt;&lt; n &lt;&lt; "*" &lt;&lt; m &lt;&lt; "矩阵&gt;[MAX]" &lt;&lt; endl; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) cin &gt;&gt; Max[i][j]; &#125; cout &lt;&lt; "请输入各进程已申请的资量&lt;" &lt;&lt; n &lt;&lt; "*" &lt;&lt; m &lt;&lt; "矩阵&gt;[Allocation]" &lt;&lt; endl; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) cin &gt;&gt; Allocation[i][j]; &#125;&#125;void init()//计算Need&#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; Need[i][j] = Max[i][j] - Allocation[i][j]; &#125; &#125;&#125;void show()//显示资源使用情况&#123; cout &lt;&lt; " Max\tAllocation\tNeed\tAvaliable" &lt;&lt; endl; for(int j = 0; j &lt; 4; j++) &#123; if(j==3) cout&lt;&lt;" "; for(int i = 0; i &lt; m; i++) &#123; cout &lt;&lt; name[i] &lt;&lt; " "; if(j == 1) cout &lt;&lt; " "; &#125; cout &lt;&lt; "\t"; &#125; cout&lt;&lt;endl; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; cout &lt;&lt; Max[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; "\t"; for(int j = 0; j &lt; m; j++) &#123; cout &lt;&lt; Allocation[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; "\t"; for(int j = 0; j &lt; m; j++) &#123; cout &lt;&lt; Need[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; "\t "; for(int j = 0; j &lt; m; j++) &#123; cout &lt;&lt; Available[j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;void update(int i, int Request[]) //更新数据&#123; for(int j = 0; j &lt; m; j++) &#123; Available[j] -= Request[j]; Allocation[i][j] += Request[j]; Need[i][j] -= Request[j]; &#125;&#125;void recovery(int i, int Request[])//还原数据&#123; for(int j = 0; j &lt; m; j++) &#123; Available[j] += Request[j]; Allocation[i][j] -= Request[j]; Need[i][j] += Request[j]; &#125;&#125;bool check_bank(int i, int Request[]) //按照银行家算法检查资源请求&#123; for(int j = 0; j &lt; m; j++) &#123; if(Request[j] &gt; Need[i][j] || Request[j] &gt; Available[j]) return false; &#125; update(i, Request); return true;&#125;void Dfs(int i, int Work[], bool Finished[])//深度优先搜索,找到所有的安全序列&#123; if(i == n) &#123; for(int j = 0; j &lt; n; j++) &#123; if(Finished[j] == false) &#123; return ; &#125; &#125; sta = Safe; SafeOrder.push_back(temp); //temp.clear(); return; &#125; for(int j = 0; j &lt; n; j++) &#123; if(Finished[j] == false) &#123; bool t = true; for(int k = 0; k &lt; m; k++) &#123; if(Need[j][k] &gt; Work[k]) &#123; t = false; break; &#125; &#125; if(t == true) &#123; for(int k = 0; k &lt; m; k++) Work[k] += Allocation[j][k]; Finished[j] = true; temp.push_back(j); Dfs(i + 1, Work, Finished); temp.pop_back(); //回溯,将第i个进程所做的改变恢复 for(int k = 0; k &lt; m; k++) &#123; Work[k] -= Allocation[j][k]; &#125; Finished[j] = false; &#125; &#125; &#125; return ;&#125;int check_safe(int i, int Request[]) //检查系统安全性&#123; int Work[MaxNumber]; bool Finished[MaxNumber]; memset(Finished, false, sizeof(Finished)); for(int i = 0; i &lt; m; i++) Work[i] = Available[i]; sta = UnSafe; Dfs(0, Work, Finished); if(sta==UnSafe) recovery(i, Request);//还原数据 return sta;&#125;void request()//某个进程申请资源&#123; int i; memset(Request, 0, sizeof(Request)); cout &lt;&lt; "请输入要请求分配资源的进程号&lt;0~" &lt;&lt; n &lt;&lt; "&gt;:"; cin &gt;&gt; i; cout &lt;&lt; "请输入进程" &lt;&lt; i &lt;&lt; "申请的资源数目" &lt;&lt; endl; for(int j = 0; j &lt; m; j++) &#123; cout &lt;&lt; name[j] &lt;&lt; ":"; cin &gt;&gt; Request[j]; &#125; SafeOrder.clear(); if(check_bank(i, Request) == true) &#123; if(check_safe(i, Request) == Safe) &#123; cout &lt;&lt; "系统是安全的!" &lt;&lt; endl; cout &lt;&lt; "安全序列有:"&lt;&lt;SafeOrder.size()&lt;&lt;"种"&lt;&lt;endl; for(int j = 0; j &lt; SafeOrder.size(); j++)//输出所有的安全序列 &#123; for(int k = 0; k &lt; SafeOrder[j].size(); k++) &#123; cout &lt;&lt; "P" &lt;&lt; SafeOrder[j][k]; if(k != SafeOrder[j].size() - 1) cout &lt;&lt; "-&gt;"; &#125; if(SafeOrder[j].size()!=0) cout &lt;&lt; endl; &#125; return; &#125; else &#123; cout &lt;&lt; "系统不安全,恢复原来状态!" &lt;&lt; endl; return; &#125; &#125; else cout &lt;&lt; "资源请求不合理!" &lt;&lt; endl; return;&#125;void choose()//选择菜单&#123; char i = -1; while(true) &#123; fflush(stdin); cout &lt;&lt; "请选择你要进行的操作" &lt;&lt; endl; cin &gt;&gt; i; switch(i) &#123; case '0': exit(0); break; case '2': request(); break; case '1': show(); break; default: cout &lt;&lt; "输入有误,请重新输入" &lt;&lt; endl; &#125; menu(); &#125;&#125;void menu()//显示菜单&#123; cout &lt;&lt; "****************银行家算法演示***************" &lt;&lt; endl; cout &lt;&lt; "\t\t1:显示各个矩阵的内容" &lt;&lt; endl; cout &lt;&lt; "\t\t2:进程请求系统分配资源" &lt;&lt; endl; cout &lt;&lt; "\t\t0:退出程序" &lt;&lt; endl; cout &lt;&lt; "*********************************************" &lt;&lt; endl;&#125;int main()&#123; //freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); input(); init(); menu(); choose(); return 0;&#125; 参考资料银行家算法实现——找出所有安全序列百度百科_银行家算法《计算机操作系统（第四版）》，汤小丹，西安电子科技大学出版社，2014.5]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Python实现校园通知更新提醒]]></title>
    <url>%2F45013.html</url>
    <content type="text"><![CDATA[前言这个项目实已经在一个月前已经完成了，一直都想写一篇博客来总结这个过程中遇到的一些问题。但最近一个月来都比较忙，所以一直拖到了现在。首先说说起因吧，我没事的时候，总喜欢依次点开学校主页、教务处、图书馆以及学院的网站，看看有没有什么新通知，虽然大多与我无关。恰逢最近正在学Python，经常听到别人说用Python写爬虫很简单，但自己尚未接触过爬虫。于是抱着试一试的心态看了几篇关于Python爬虫的博客，发现实现起来的确很简单。于是，便一边看着官方的文档说明，一边看着别人的博客，终于完成了自己的第一次爬虫。 简介使用urllib.request库获取到目标url(各个网站的’更多通知’页)的源代码，然后利用Python的re库进行正则匹配，提取到通知相关信息后，与文件中存取的上一次爬取到的信息进行对比。若检测到有新的通知，则利用twilio库向指定手机号码发送SMS，利用smtplib库向指定邮箱发送提醒信息。此外，还具有发送日志以及异常日志的功能。目前仅支持本校的通知提醒，后续会逐步提高项目的通用性。 源码：Github地址:School_Notice 准备工作 安装twilio库:pip install twilio 注册twilio账号:Twilio 验证手机号:用来接收短信提醒的号码必须在twilio上进行验证 遇到的问题邮件发送 若用名为msg的变量来保存邮件文本，则msg[&#39;From&#39;]以及msg[&#39;To&#39;]必须为实际的发件人地址，否则可能会出现异常:SMTPDataError(code, resp).如必须写作:msg[&#39;From&#39;] = &#39;xxxxx@qq.com&#39;.我是使用的QQ邮箱来发邮件，至于其他邮箱需不需要这样写还不清楚。 原本想用一个for循环来实现多人发送，后来发现smtplib库的sendmail方法支持多人发送，但参数应为一个list，故可用str.split(&#39;,&#39;)将字符串转为list。 我使用的是Windows下的Python，若计算机名为中文，则有可能会导致出现异常，可通过右击此电脑-&gt;属性，修改计算机名。 程序代码中使用的邮箱密码不是QQ密码，应在邮箱设置-&gt;账户-&gt;SMTP服务处，获取授权码。 其他问题 有时候会接收不到Twilio发送的短信，给10086打电话也没问出个所以然，可能是因为短信中有敏感词(如:学校名)，修改短信内容后就可以了 对上述几个网站的源码使用re.findall后返回的列表中的每个元组中的元素的顺序均为时间、标题、链接，但对学生处网站的源码正则匹配后的元素顺序并不是按照上述顺序的。所以应单独进行调整，但直接修改一个元组中的元素，会出现异常:error:tuple&#39; object does not support item assignment。解决方法是: 123456if(subject_EN == 'snnu_xsc'): new_data = [] for item in data: temp = (item[1], item[2], item[0]) new_data.append(temp) data = new_data Python3中的print函数是自动换行的，若不需要自动换行，则可写作:print(str,end=&#39;&#39;) 不同网站的编码格式可能不同，应按照各自的编码方式进行解码。若均采用utf-8的方式，则可能会出现各种编码问题，如:UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xc9 in position 167解决方法是:1234567if find1 == -1 &amp; find2 == -1: Coding = 'utf-8'else: # 教务处网页源码编码格式为为gbk # 学生处网页源码编码格式为gb2312 Coding = 'gbk'data = response.read().decode(Coding) Python程序打包为exe(Pyinstaller)安装及使用 使用pip install pywin32安装pywin32 使用pip install PyInstaller安装Pyinstaller 使用pyinstaller -F main.py即可将Python程序打包为exe程序 注意事项 打包之前应将用到的第三方库(此项目仅用到Twilio)复制到与要打包的py文件同一目录下。 可使用pyinstaller -F -i logo.ico main.py,为生成的exe程序添加图标 使用的ico文件像素不能过小，否则有可能出现:打包后的程序图标只有在资源管理器中设置为以小图标查看的情况下才显示的是自己的图标，其他情况仍未默认图标 使用截图 参考博客 应用python对校园通知的更新进行推送 使用python发短信给自己的手机 Python打包方法——Pyinstaller]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Twilio</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github pages个人域名添加SSL]]></title>
    <url>%2F18543.html</url>
    <content type="text"><![CDATA[前言寒假的时候用Hexo+Github pages搭建了属于自己的博客，前不久才绑定了个人域名。作为一名有强迫症的程序猿，肯定还要给自己加一个绿色的小锁头。在网上看别人的博客，大部分是用的CloudFlare提供的免费https服务，也有采用的阿里云提供的一年免费证书，我选择的是后者。 准备 个人域名:https://赵旗.top/ Github pages 阿里云购买的SSL证书添加SSL证书 进入阿里云控制台，依次点击安全(云盾)-&gt;CA证书服务，然后点击右上角的购买证书。 依次选择品牌为Symantec，保护类型为一个域名，证书类型此时会多出一个选项免费型DV SSL点击选择,然后点击立即购买，支付0.00元。注意:免费的SSL证书有效期只有一年，过期之后就需要重新申请了。 支付成功后，点击进入证书控制台，然后点击补全，填写相关信息，提交申请。域名验证类型选项记得勾选:证书绑定的域名在【阿里云的云解析】产品中，授权系统自动添加一条记录以完成域名授权验证。 等待20分钟左右，即可收到签发成功的通知了，也可以在证书控制台中实时看到审核进度。 在浏览器中输入https://域名/ ，可以看到地址栏前面有一个小绿锁，很惊喜有没有~ http强制跳转https按照上述步骤添加了SSL证书后，发现如果在地址栏中输入的是https://域名/ 就会有绿锁头，如果输入的是http://域名/ ，则还是http,并不会自动跳转至https。怎样让访客点击http://域名/ 时能强制跳转到https呢？在Google上看了好多的博客都没能找到解决方案，突然发现Github上有一个Enforce HTTPS选项，抱着试一试的心态，最后竟然成功了。 登录Github，进入自己的Github.io项目中，点击Setting，往下拉，可以看到有个选项叫Enforce HTTPS,点击勾选。 打开浏览器，在地址中输入自己的http://域名/ ，已经可以自动跳转到https下了，大功告成。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L2-3.名人堂与代金券]]></title>
    <url>%2F45393.html</url>
    <content type="text"><![CDATA[题目内容对于在中国大学MOOC(http://www.icourse163.org/) 学习“数据结构”课程的学生，想要获得一张合格证书，总评成绩必须达到 60 分及以上，并且有另加福利：总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G) 区间内者，可以得到 20 元PAT代金券。全国考点通用，一年有效。同时任课老师还会把总评成绩前 K 名的学生列入课程“名人堂”。本题就请你编写程序，帮助老师列出名人堂的学生，并统计一共发出了面值多少元的 PAT 代金券。 输入格式输入在第一行给出 3 个整数，分别是 N（不超过 10 000 的正整数，为学生总数）、G（在 (60,100) 区间内的整数，为题面中描述的代金券等级分界线）、K（不超过 100 且不超过 N 的正整数，为进入名人堂的最低名次）。接下来 N 行，每行给出一位学生的账号（长度不超过15位、不带空格的字符串）和总评成绩（区间 [0, 100] 内的整数），其间以空格分隔。题目保证没有重复的账号。 输出格式首先在一行中输出发出的 PAT 代金券的总面值。然后按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩，其间以 1 个空格分隔。需要注意的是：成绩相同的学生享有并列的排名，排名并列时，按账号的字母序升序输出。 输入样例10 80 5cy@zju.edu.cn 78cy@pat-edu.com 871001@qq.com 65uh-oh@163.com 96test@126.com 39anyone@qq.com 87zoe@mit.edu 80jack@ucla.edu 88bob@cmu.edu 80ken@163.com 70 输出样例3601 uh-oh@163.com 962 jack@ucla.edu 883 anyone@qq.com 873 cy@pat-edu.com 875 bob@cmu.edu 805 zoe@mit.edu 80 时间限制：150ms内存限制：65536kb 代码解法一用一个结构体来存姓名和成绩，再用自定义的比较函数sort一下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct stu&#123; string name; int grade;&#125;;bool cmp(const stu&amp; s1, const stu&amp; s2)&#123; if(s1.grade != s2.grade) return s1.grade &gt; s2.grade; else return s1.name &lt; s2.name;&#125;int main()&#123; //freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); cin.sync_with_stdio(false); int n, g, k; cin &gt;&gt; n &gt;&gt; g &gt;&gt; k; vector&lt;stu&gt; v; ll ans = 0; for(int i = 0; i &lt; n; i++) &#123; string temp1; int temp2; cin &gt;&gt; temp1 &gt;&gt; temp2; stu temp; temp.name = temp1; temp.grade = temp2; v.push_back(temp); if(temp2 &gt;= 60) &#123; if(temp2 &lt; g) ans += 20; else ans += 50; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; int index = 1; int number = 1; sort(v.begin(), v.end(), cmp); vector&lt;stu&gt;::iterator t; ll flag = v[0].grade; for(t = v.begin(); t != v.end(); t++) &#123; if(flag != (*t).grade) &#123; flag = (*t).grade; index = number; &#125; if(index &gt; k) break; cout &lt;&lt; index &lt;&lt; " " &lt;&lt; (*t).name &lt;&lt; " " &lt;&lt; (*t).grade &lt;&lt; endl; number++; &#125; return 0;&#125; 解法二用一个map&lt;string,name&gt;来存name和grade,将map转存到vcetor到中进行排序。比赛的时候好蠢好蠢的做法，后面会说。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool cmp (const pair&lt;string,int&gt;&amp; a,const pair&lt;string,int&gt;&amp; b)&#123; if(a.second!=b.second) return a.second&gt;b.second; else return a.first&lt;b.first;&#125;int main()&#123; //freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); cin.sync_with_stdio(false); int n,g,k; cin&gt;&gt;n&gt;&gt;g&gt;&gt;k; map&lt;string,int&gt; m; ll ans=0; for(int i=0;i&lt;n;i++) &#123; string temp1; int temp2; cin&gt;&gt;temp1&gt;&gt;temp2; m.insert(pair&lt;string,int&gt;(temp1,temp2)); if(temp2&gt;=60) &#123; if(temp2&lt;g) ans+=20; else ans+=50; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; vector&lt;pair&lt;string,int&gt;&gt; mm(m.begin(),m.end());//map转存至vector sort(mm.begin(),mm.end(),cmp); int index=1; int number=1; vector&lt;pair&lt;string,int&gt;&gt;::iterator t=mm.begin(); ll flag=(*t).second; for(t=mm.begin();t!=mm.end();t++) &#123; if(flag!=(*t).second) &#123; flag=(*t).second; index=number; &#125; if(index&gt;k) break; cout&lt;&lt;index&lt;&lt;" "&lt;&lt;(*t).first&lt;&lt;" "&lt;&lt;(*t).second&lt;&lt;endl; number++; &#125; return 0;&#125; 总结比赛的时候没看清题意，上来就直接一个map，快写完了的时候才发现不对，然后就突发奇想的对map进行sort，但是编译的时候比较函数那一行一直报错。我到现在都不清楚为什么比赛的时候要一直死磕对map按照value进行sort，就是懒得改成结构体加vector，结果直到比赛结束前几分钟才开始改，虽然改完了可惜没时间交了。回到宿舍终于在网上找到了对map进行sort的方法：将map转存至vector中，然后sort。vector&lt;pair&lt;string,int&gt;&gt; mm(m.begin(),m.end());但是还是用结构体加vector方便啊。还是自己菜啊……. 注意：STL库中的sort函数只能对线性存储的对象进行排序,如:vector、array、list、deque,不能对集合容器进行排序,如:set、map; 参考博客:C++ STL中Map的按Key排序和按Value排序]]></content>
      <categories>
        <category>CCCC天梯赛</category>
      </categories>
      <tags>
        <tag>CCCC天梯赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github pages博客绑定中文域名]]></title>
    <url>%2F24787.html</url>
    <content type="text"><![CDATA[摘要近期又开始了hexo的折腾，在阿里云上买了一个属于自己的域名，因此想着把自己用hexo+Github搭建的博客通过域名访问，于是按照百度上的教程一步一步来绑定域名，结果出现了很多问题 。整个过程可谓一波三折，终于实现了通过域名来访问博客，下面简要介绍一下我绑定域名过程中遇到的问题以及解决方案。 购买域名这里以在阿里云上购买域名为例,大家也可以去其他平台购买域名。登录阿里云，点击产品，选择域名注册。注册域名前需查询域名是否已被注册，选择自己喜欢的域名，支付即可。一般来说，.top与.xyz结尾的域名都比较便宜。为了节约成本，我买的.top结尾的域名，一年只需两块钱，很便宜。 域名解析购买域名后，我们依次点击个人昵称-&gt;域名与网站(万网)-&gt;域名，进入管理控制台，在这里我们可以看到自己购买的域名,点击解析，进入解析设置。点击添加解析，依次输入：CNAME、@、Github博客地址，点击确定，完成个人域名向个人博客的映射。 注意：这里填入博客地址的时候无需填写https:// ，只需按照example.github.io格式填写就行了。 创建CNAME文件在本地的根目录下的source文件夹中新建一个名为CNAME的文本文件，文件内容为个人域名（没有http:// ,也没有www.）,然后重命名删除该文件的后缀名:.txt。使用hexo d -g命令部署博客，这时在浏览器中输入新注册的域名，已经可以正常的访问博客了。 英文域名英文域名就直接写:example.con 中文域名中文域名的话,则需先将中文域名转换为Punycode标准编码的字符串:中文域名转换Punycode标准编码工具For example:例子.中文经过转换为xn--fsqu00a.xn--fiq228c将xn--****.xn--***填入CNAME文件即可。 如果直接在CNAME文件中填写中文域名,则Github会通过邮件提醒你:The CNAME xxx.com is not properly formatted. See https://help.github.com/articles/troubleshooting-custom-domains/#github-repository-setup-errors for more information. LeanCloud数据丢失通过域名访问博客，发现文章的阅读次数不显示，于是各种折腾：检查元素、谷歌，最后发现是由于没有将新注册的域名加入到LeanCloud设置中的Web 安全域名,导致无法调用服务器资源。解决方案：访问：LeanCloud官网,进入控制台，在设置中点击安全中心，将新注册的域名加入到Web安全域名中，点击保存即可。 busuanzi数据丢失无论是通过域名还是github地址访问博客，博客底部的统计浏览量与浏览人次均不是以前的数据，而是从头开始计算….busuanzi还不具备统初始值的功能，只能从头开始计算了。。。 拓展中文域名１、一类是域名后缀为英文字母的国际中文域名和别国中文域名，比如：中文.com，中文.net，中文.biz，中文.cc，中文.hk，中文.tm，中文.tv，中文.tw；２、一类是域名后缀为中文的纯中文国内中文域名，比如：中文域名.中国，中文域名.公司，中文域名.网络；中文域名在解析的时候，需要先转换为 xn–fiq228c.com或xn–fiq228c.cn形式的ASCII码，这种编码称为PunyCode。纯中文域名不被标准的解析服务器支持，要实现对这种纯中文域名的正确访问，ISP需要做相应的修改，以便能够正确解析中文域名。同时CNNIC也提供了专用服务器，用户只要将浏览器的DNS设置指向这台服务器，它同样可以完成对纯中文域名的正确解析。另外，考虑到现在有些ISP还没有做修改，而有些用户又不方便将DNS设置指向CNNIC提供的服务器，纯中文域名会被加上.cn后缀，即对每一个纯中文域名同时有两种形式：纯中文域名和纯中文域名.CN， 如：”中文域名.网络”和”中文域名.网络.CN”。这样即使ISP还没有做相应的修改，用户也可以正确使用中文域名。 PunyCode英文域名在IIS或Apache中的虚拟主机设置，可以直接使用英文域名，如webmasterhome.cn。中文域名在IIS或Apache中应如何设置主机头呢？如”中国站长之家.com”。1、在进行设置之前要先把中文域名转化成为PunyCode编码，然后在主机头设置里面填上中文域名所对应的PunyCode编码(｀xn–fiqsC146Ah4ex80Cro7A.com｀)便可。新的国际化域名的标准在网域名称编码上，为了保留向下兼容性及不影响现有的应用程序协议，因此将多国语言域名转成ASCII编码，而这种编码称为『punycode』。因为经过Nameprep处理过的国际化域名是以 Unicode 序列的形式表示的。但现有的 DNS系统只支持用 ASCII字符表示的域名，所以要对Unicode序列进行 ACE(ASCII-compatible encoding)编码，把 Unicode序列表示的域名转换成 ASCII 字符串表示的ACE域名。2、PunyCode是一种专为国际化域名而设计的高效ACE编码方式。它可以在Unicode序列和ASCII 字符串之间进行唯一的和可逆的转换。转换的过程中，Unicode 序列中的ASCII字符保持不变，国际化字符则用字母和数字来表示。它的实质是一种用数量有限的基本字符(字母和数字)来唯一地表示大字符集(Unicode)中的字符的通用算法。域名中的字符，包括 ASCII 码和 Unicode 码，都是作为整数进行处理。PunyCode则是将一个经过Nameprep处理过的IDN，从一个8位的编码的形式转换为7位编码的形式。目前Internet DNS一向是7位ASCII编码的环境，经过这个PunyCode转码程序，便将IDN从一个8位的IDN转换为与现有DNS环境兼容的编码。3、在DNS服务器方面，需要将IDN以PunyCode的编码形式来设定。因为PunyCode本身就是一种7位的编码，与ASCII编码完全兼容，所以可适用设定于目前所有可用的DNS版本,也就是说可以不需要为了设定PunyCode而重新安装BIND新版本。但是若是需要使用DNAME指令来设定资源记录(Resource Record)，则需先提升为BIND9的版本。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[期末考试_细胞自动机]]></title>
    <url>%2F6200.html</url>
    <content type="text"><![CDATA[题目内容：这是细胞自动机的非图形版本。细胞自动机是指在一个二维网格内，每一个网格是一个细胞。每个细胞有活和死两种状态。初始时刻，有些细胞是活的，有些细胞是死的。自动机的每一步，根据每个细胞周围8个格子内的其他细胞的生存情况决定这个细胞下一步是否存活。具体的规则如下： 如果该细胞现在是活的，并且周围8个格子中有2或3个活着的细胞，则继续存活；如果周围8个格子中的活着的细胞数量少于2个或多于3个，则死亡； 如果该细胞现在是死的，并且周围8个格子中正好有3个活着的细胞，则细胞复活。 位于整个网格边缘和顶角的细胞，它的周围细胞可能少于8个。即越过网格的边界不再有细胞。 每个细胞的生死变化，都不会影响当前这一步周围的细胞，只会在下一步表现出来。 提示：课程中的代码与上一句描述不同。 输入格式:首先输入两个正整数，范围为[3,102]，依次表示网格的宽度和高度。然后输入多组正整数，依次表示一个活着的细胞的网格位置，每组数字中，第一个表示行号，第二个表示列号，均从0开始编号。最后，以“-1 -1”表示不再有活着的细胞。-1 -1不是有效的位置。然后，以一个正整数，范围为[1,10000]，表示要求细胞自动机执行的步数。 输出格式：输出一个正整数，表示执行完毕后，剩下的活着的细胞的数量。 输入样例：3 31 1 1 2 0 1 2 1-1 -11## 输出样例：7 时间限制：500ms内存限制：32000kb 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package 面向对象程序设计_Java语言_翁恺;import java.util.Scanner;public class The_final_exam&#123; private int times; private int width; private int height; int old_field[][]; int new_field[][]; Scanner in = new Scanner(System.in); void Init() &#123; width = in.nextInt(); height = in.nextInt(); old_field = new int[height+2][width+2]; new_field = new int[height+2][width+2]; // 初始化为0 for (int i = 0; i &lt; height+2; i++) for (int j = 0; j &lt; width+2; j++) &#123; old_field[i][j] = 0; old_field[i][j] = 0; &#125; //读入活的细胞的位置 while(true) &#123; int i=in.nextInt(); int j=in.nextInt(); if(i==-1&amp;&amp;j==-1) break; old_field[i+1][j+1]=1; new_field[i+1][j+1]=1; &#125; //读入执行步数 times = in.nextInt(); &#125; void run() &#123; for(int k=0;k&lt;times;k++) &#123; for(int i=1;i&lt;height+1;i++) &#123; for(int j=1;j&lt;width+1;j++) &#123; int count=getNeighbor(i, j); if(old_field[i][j]==0) &#123; if(count==3)//细胞复活 new_field[i][j]=1; &#125; else &#123; if(!(count==2||count==3))//细胞死亡 new_field[i][j]=0; &#125; &#125; &#125; //copy for (int i = 1; i &lt; height+1; i++) &#123; for (int j = 0; j &lt; width+1; j++) &#123; old_field[i][j] = new_field[i][j]; &#125; &#125; &#125; &#125; int getNeighbor(int i,int j) &#123; //计算位置为i，j的细胞周围活的细胞的数量 int temp=0; temp+=old_field[i-1][j]+old_field[i+1][j]+old_field[i][j-1]+old_field[i][j+1]; temp+=old_field[i-1][j-1]+old_field[i-1][j+1]+old_field[i+1][j-1]+old_field[i+1][j+1]; return temp; &#125; int Count() &#123; //计算活着的细胞的数量 int count=0; for (int i = 1; i &lt; height+1; i++) &#123; for (int j = 1; j &lt; width+1; j++) &#123; if(old_field[i][j]==1) count++; &#125; &#125; return count; &#125; void Test() &#123; Init(); run(); System.out.println(Count()); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub new The_final_exam().Test(); &#125;&#125; 思路：简单模拟题….用两个二维数组来存细胞，细胞自动机每执行一次，遍历数组1一次，对数组1中每个细胞的状态进行判断，计算周围活着的细胞的数量，然后对数组2进行相应的操作，所有操作完成后将数组2拷贝至数组1。这里判断细胞周围活着的细胞数量时有一个小技巧，不需要对每种边界情况进行处理,可以将数组开大点，下标从1开始使用，相当于在所使用的有效数组空间外面绕了一圈，避免数组越界。]]></content>
      <categories>
        <category>面向对象程序设计_Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Python绘制七段数码管]]></title>
    <url>%2F48183.html</url>
    <content type="text"><![CDATA[题目：数码管是一种价格便宜、使用简单的发光电子器件，广泛应用在价格较低的电子类产品中，其中，七段数码管最为常用。七段数码管（seven-segment indicator）由7 段数码管拼接而成，每段有亮或不亮两种情况，改进型的七段数码管还包括一个小数点位置，如图1 所示。 图 1：七段数码管的结构图七段数码管能形成27=128 种不同状态，其中部分状态能够显示易于人们理解的数字或字母含义，因此被广泛使用。图2 给出了十六进制中16 个字符的七段数码管表示。 图 2：十六进制中16 个字符的七段数码管表示请采用turtle 库并使用函数封装绘制七段数码管，显示当前系统日期和时间。该问题的IPO 描述如下：输入：当前日期的数字形式处理：根据每个数字绘制七段数码管表示输出：绘制当前日期的七段数码管表示程序的预期运行效果如图3 和图4 所示，与两个效果中任何一个相似均可。 源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980'''Created on Dec 5, 2017@author: QiZhao'''import turtle,datetime def drawGap():#画数码管间隔 turtle.penup() turtle.fd(5) def drawline(flag):#画单条数码管 drawGap() turtle.pendown() if(flag==False): turtle.penup() turtle.fd(40) drawGap() turtle.right(90) def drawdight(dight):#根据数字绘制对应数字的数码管 if dight in [2,3,4,5,6,8,9]: drawline(True) else: drawline(False) if dight in [0,1,3,4,5,6,7,8,9]: drawline(True) else: drawline(False) if dight in [0,2,3,5,6,8]: drawline(True) else: drawline(False) if dight in [0,2,6,8]: drawline(True) else: drawline(False) turtle.left(90) if dight in [0,4,5,6,8,9]: drawline(True) else: drawline(False) if dight in [0,2,3,5,6,7,8,9]: drawline(True) else: drawline(False) if dight in [0,1,2,3,4,7,8,9]: drawline(True) else: drawline(False) turtle.setheading(0) turtle.fd(25)def drawdata(data):#根据日期画出对应数字 turtle.color("red") for i in data: if i=='+': turtle.write('年',font=("宋体", 24, "normal")) turtle.color("green") turtle.fd(30) elif i=='-': turtle.write('月',font=("宋体", 24, "normal")) turtle.color("blue") turtle.fd(30) elif i=='*': turtle.write('日',font=("宋体", 24, "normal")) else: drawdight(eval(i)) def main(): turtle.setup(800,500) turtle.penup() turtle.fd(-350) turtle.pendown() turtle.hideturtle() turtle.pensize(6) turtle.speed(9) drawdata(datetime.datetime.now().strftime('%Y+%m-%d*')) a=input()main() 效果图]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python画小树和森林（宽度优先绘制+深度优先绘制)]]></title>
    <url>%2F15900.html</url>
    <content type="text"><![CDATA[在中M上看嵩天老师的《Python语言程序设计》时,视频中给出了宽度优先绘制法的代码,仅提了一下还有另外一种画法(深度优先绘制法).联系到最近学的数据结构，摸索出了另一种画法。 源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071'''Created on Dec 2, 2017@author: QiZhao'''# drawtree.py from turtle import Turtle def tree(plist, l, a, f): #宽度优先绘制法 """ plist is list of pens l is length of branch a is half of the angle between 2 branches f is factor by which branch is shortened from level to level.""" if l &gt; 5: lst = [] for p in plist: p.forward(l)#Move the turtle forward by the specified distance, in the direction the turtle is headed. q = p.clone()#Create and return a clone of the turtle with same position, heading and turtle properties. p.left(a) #Turn turtle left by angle units q.right(a)# turn turtle right by angle units, nits are by default degrees, but can be set via the degrees() and radians() functions. lst.append(p) lst.append(q) tree(lst, l*f, a, f) def tree2(p,l,a,f): #深度优先绘制法 if l&gt;5: p.forward(l) q=p.clone() p.left(a) q.right(a) tree2(p, l*f, a, f) tree2(q, l*f, a, f)def maketree(x,y): p = Turtle() p.color("blue") p.pensize(5) p.setundobuffer(None) p.hideturtle() #Make the turtle invisible. It’s a good idea to do this while you’re in the middle of doing some complex drawing, #because hiding the turtle speeds up the drawing observably. #p.speed(9) p.getscreen().tracer(1,0)#Return the TurtleScreen object the turtle is drawing on. #TurtleScreen methods can then be called for that object. p.left(90)# Turn turtle left by angle units. direction p.penup() #Pull the pen up – no drawing when moving. p.goto(x,y)#Move turtle to an absolute position. If the pen is down, draw line. Do not change the turtle’s orientation. p.pendown()# Pull the pen down – drawing when moving. #这三条语句是一个组合相当于先把笔收起来再移动到指定位置，再把笔放下开始画.否则turtle一移动就会自动的把线画出来 tree([p], 100, 65, 0.6375) p.penup() p.setheading(90)#Set the orientation of the turtle to to_angle. p.goto(x,y) p.down() p.color("green") tree2(p, 100, 65, 0.6375) def main(): maketree(-200, -200) maketree(0, 0) maketree(200,-200) main() 效果图]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python的turtle库绘制玫瑰]]></title>
    <url>%2F17747.html</url>
    <content type="text"><![CDATA[turtle的文档：用Python的turtle库绘图是很简单的,闲来无事就画了一个玫瑰花,下面奉上源码…. 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293'''Created on Nov 18, 2017@author: QiZhao'''import turtle# 设置初始位置turtle.penup()turtle.left(90)turtle.fd(200)turtle.pendown()turtle.right(90)# 花蕊turtle.fillcolor("red")turtle.begin_fill()turtle.circle(10,180)turtle.circle(25,110)turtle.left(50)turtle.circle(60,45)turtle.circle(20,170)turtle.right(24)turtle.fd(30)turtle.left(10)turtle.circle(30,110)turtle.fd(20)turtle.left(40)turtle.circle(90,70)turtle.circle(30,150)turtle.right(30)turtle.fd(15)turtle.circle(80,90)turtle.left(15)turtle.fd(45)turtle.right(165)turtle.fd(20)turtle.left(155)turtle.circle(150,80)turtle.left(50)turtle.circle(150,90)turtle.end_fill() # 花瓣1turtle.left(150)turtle.circle(-90,70)turtle.left(20)turtle.circle(75,105)turtle.setheading(60)turtle.circle(80,98)turtle.circle(-90,40)# 花瓣2turtle.left(180)turtle.circle(90,40)turtle.circle(-80,98)turtle.setheading(-83)# 叶子1turtle.fd(30)turtle.left(90)turtle.fd(25)turtle.left(45)turtle.fillcolor("green")turtle.begin_fill()turtle.circle(-80,90)turtle.right(90)turtle.circle(-80,90)turtle.end_fill() turtle.right(135)turtle.fd(60)turtle.left(180)turtle.fd(85)turtle.left(90)turtle.fd(80) # 叶子2turtle.right(90)turtle.right(45)turtle.fillcolor("green")turtle.begin_fill()turtle.circle(80,90)turtle.left(90)turtle.circle(80,90)turtle.end_fill() turtle.left(135)turtle.fd(60)turtle.left(180)turtle.fd(60)turtle.right(90)turtle.circle(200,60) 效果图]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六周编程题_GPS数据处理]]></title>
    <url>%2F48389.html</url>
    <content type="text"><![CDATA[题目内容：NMEA-0183协议是为了在不同的GPS（全球定位系统）导航设备中建立统一的BTCM（海事无线电技术委员会）标准，由美国国家海洋电子协会（NMEA-The National Marine Electronics Associa-tion）制定的一套通讯协议。GPS接收机根据NMEA-0183协议的标准规范，将位置、速度等信息通过串口传送到PC机、PDA等设备。 NMEA-0183协议是GPS接收机应当遵守的标准协议，也是目前GPS接收机上使用最广泛的协议，大多数常见的GPS接收机、GPS数据处理软件、导航软件都遵守或者至少兼容这个协议。 NMEA-0183协议定义的语句非常多，但是常用的或者说兼容性最广的语句只有$GPGGA、$GPGSA、$GPGSV、$GPRMC、$GPVTG、$GPGLL等。 其中$GPRMC语句的格式如下：$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50 这里整条语句是一个文本行，行中以逗号“,”隔开各个字段，每个字段的大小（长度）不一，这里的示例只是一种可能，并不能认为字段的大小就如上述例句一样。 字段0：$GPRMC，语句ID，表明该语句为Recommended Minimum Specific GPS/TRANSIT Data（RMC）推荐最小定位信息字段1：UTC时间，hhmmss.sss格式字段2：状态，A=定位，V=未定位字段3：纬度ddmm.mmmm，度分格式（前导位数不足则补0）字段4：纬度N（北纬）或S（南纬）字段5：经度dddmm.mmmm，度分格式（前导位数不足则补0）字段6：经度E（东经）或W（西经）字段7：速度，节，Knots字段8：方位角，度字段9：UTC日期，DDMMYY格式字段10：磁偏角，（000 - 180）度（前导位数不足则补0）字段11：磁偏角方向，E=东W=西字段16：校验值 这里，“”为校验和识别符，其后面的两位数为校验和，代表了“$”和“”之间所有字符（不包括这两个字符）的异或值的十六进制值。上面这条例句的校验和是十六进制的50，也就是十进制的80。 提示：^运算符的作用是异或。将$和之间所有的字符做^运算(第一个字符和第二个字符异或，结果再和第三个字符异或，依此类推)之后的值对65536取余后的结果，应该和后面的两个十六进制数字的值相等，否则的话说明这条语句在传输中发生了错误。注意这个十六进制值中是会出现A-F的大写字母的。另外，如果你需要的话，可以用Integer.parseInt(s)从String变量s中得到其所表达的整数数字；而Integer.parseInt(s, 16)从String变量s中得到其所表达的十六进制数字 现在，你的程序要读入一系列GPS输出，其中包含$GPRMC，也包含其他语句。在数据的最后，有一行单独的END表示数据的结束。 你的程序要从中找出$GPRMC语句，计算校验和，找出其中校验正确，并且字段2表示已定位的语句，从中计算出时间，换算成北京时间。一次数据中会包含多条$GPRMC语句，以最后一条语句得到的北京时间作为结果输出。 你的程序一定会读到一条有效的$GPRMC语句。 输入格式:多条GPS语句，每条均以回车换行结束。最后一行是END三个大写字母。 输出格式：6位数时间，表达为：hh:mm:ss其中，hh是两位数的小时，不足两位时前面补0；mm是两位数的分钟，不足两位时前面补0；ss是两位数的秒，不足两位时前面补0。 输入样例：$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50END 输出样例：10:48:13 时间限制：500ms内存限制：32000kb 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package 零基础学Java语言_翁恺;import java.util.Scanner;public class Sixth_Week_2&#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub final int mod = 65536; Scanner in = new Scanner(System.in); String s = null; int hh = 0, mm = 0, ss = 0; int cnt = 0; char state = 0; String utc = null; int judge = 0; int judge_temp = 0; String temp = null; while (true) &#123; s = in.nextLine(); cnt = 0; if (s.equals(&quot;END&quot;)) // 读入结束 break; temp = s.substring(0, 6); if (temp.equals(&quot;$GPRMC&quot;)) // 判断是否为$GPRMC &#123; utc = s.substring(7, 13); temp = null; for (int i = 0; i &lt; s.length(); i++) // 获取字段2（定位） &#123; if (s.charAt(i) == &apos;,&apos;) cnt++; if (cnt == 2) &#123; state = s.charAt(i + 1); cnt = 0; break; &#125; &#125; if (state == &apos;A&apos;) // 判断是否定位 &#123; for (int i = 0; i &lt; s.length(); i++) // 获取字段16(校验值） &#123; if (s.charAt(i) == &apos;,&apos;) cnt++; if (cnt == 12) &#123; temp = s.substring(i + 3, s.length()); judge = Integer.parseInt(temp, 16); temp = null; break; &#125; &#125; judge_temp = (int)s.charAt(1) ^ (int)s.charAt(2);// 计算校验值 for (int i = 3; s.charAt(i) != &apos;*&apos;; i++) &#123; if (s.charAt(i) == &apos;,&apos;) continue; else judge_temp = judge_temp ^ (int)s.charAt(i)%mod; &#125; if (judge == judge_temp) // 判断校验值是否相等 &#123; // utc时间转换bjt时间 ss = (utc.charAt(5) - &apos;0&apos;) + (utc.charAt(4) - &apos;0&apos;) * 10; mm = (utc.charAt(3) - &apos;0&apos;) + (utc.charAt(2) - &apos;0&apos;) * 10; hh = (utc.charAt(1) - &apos;0&apos;) + (utc.charAt(0) - &apos;0&apos;) * 10 + 8; hh = hh % 24; &#125; &#125; &#125; &#125; System.out.printf(&quot;%02d:%02d:%02d&quot;, hh, mm, ss); in.close(); &#125;&#125; 做法:先判断前6个字符是否为“$GPRMC”，然后判断字段2(定位)是否为A，然后将字段16(校验值)用Integer.parseInt(str,16)方法转换为十进制，对’$’和‘*’之间的所有字符作^运算，并与校验值进行比较，再将UTC时间转换为BJT时间，并输出。注意：对字符进行^运算时，要先使用强制类型转换为int型； 输出时间时，不足两位的前面要补0； UTC时间转换为BJT时间时对跨日的处理。]]></content>
      <categories>
        <category>零基础学Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六周编程题_单词长度]]></title>
    <url>%2F26108.html</url>
    <content type="text"><![CDATA[题目内容：你的程序要读入一行文本，其中以空格分隔为若干个单词，以‘.’结束。你要输出这行文本中每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如“it’s”算一个单词，长度为4。注意，行中可能出现连续的空格。 输入格式:输入在一行中给出一行文本，以‘.’结束，结尾的句号不能计算在最后一个单词的长度内。 输出格式：在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。 输入样例：It’s great to see you here. 输出样例：4 5 2 3 3 4 时间限制：500ms内存限制：32000kb 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546package 零基础学Java语言_翁恺;import java.util.Scanner;public class Sixth_Week&#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner in = new Scanner(System.in); String s = null; int ans = 0; s = in.nextLine(); if (s.charAt(0) != '.')//处理输入为一个"."时的情况 &#123; for (int i = 0; i &lt; s.length();) &#123; for (int j = i; j &lt; s.length(); j++) &#123; i = j; if (s.charAt(j) == ' ') break; else if (s.charAt(j) == '.') break; else ans++; &#125; if (s.charAt(i) == '.') &#123; System.out.print(ans); break; &#125; else &#123; System.out.print(ans + " "); &#125; ans = 0; while (s.charAt(i) == ' ')// 行中可能出现连续的空格 i++; &#125; &#125; in.close(); &#125;&#125; 坑点:一是行中可能出现连续的空格；二是要处理好输入为”.”时的情况。]]></content>
      <categories>
        <category>零基础学Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五周编程题_多项式加法]]></title>
    <url>%2F51603.html</url>
    <content type="text"><![CDATA[题目内容：一个多项式可以表达为x的各次幂与系数乘积的和，比如：2x6+3x5+12x3+6x+20现在，你的程序要读入两个多项式，然后输出这两个多项式的和，也就是把对应的幂上的系数相加然后输出。程序要处理的幂最大为100。 输入格式:总共要输入两个多项式，每个多项式的输入格式如下：每行输入两个数字，第一个表示幂次，第二个表示该幂次的系数，所有的系数都是整数。第一行一定是最高幂，最后一行一定是0次幂。注意第一行和最后一行之间不一定按照幂次降低顺序排列；如果某个幂次的系数为0，就不出现在输入数据中了；0次幂的系数为0时还是会出现在输入数据中。 输出格式：从最高幂开始依次降到0幂，如：2x6+3x5+12x3-6x+20注意其中的x是小写字母x，而且所有的符号之间都没有空格，如果某个幂的系数为0则不需要有那项。 输入样例：6 25 33 121 60 206 25 32 121 60 20 输出样例：4x6+6x5+12x3+12x2+12x+40 时间限制：500ms内存限制：32000kb 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package 零基础学Java语言_翁恺;import java.util.Scanner;public class Fifth_Week&#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner in = new Scanner(System.in); int[] a = new int[101]; int m = 0, n = 0; boolean flag = false; for(int i=0;i&lt;100;i++) a[i]=0; int m_max = 0; // 读入第一个多项式 do &#123; m = in.nextInt(); n = in.nextInt(); a[m] = n; if (m &gt; m_max) m_max = m; &#125;while(m!=0); // 读入第二个多项式 do &#123; m = in.nextInt(); n = in.nextInt(); a[m] += n; if (m &gt; m_max) m_max = m; &#125;while (m!=0); for (int j = m_max; j &gt;=0; j--) &#123; if (a[j] != 0) &#123; if(a[j]&gt;0&amp;&amp;flag==true) System.out.print("+"); if(a[j]!=1) System.out.print(a[j]); if(j!=1&amp;&amp;j!=0) System.out.print("x"+j); if(j==1) System.out.print("x"); flag=true; &#125; &#125; in.close(); &#125;&#125; 只有一个测试点没过…..不想改了….. 总结：用一个大小为101的数组来存系数，数组的下标即为幂指数….若系数不为0则输出…需要注意的是： 系数为1或-1时不用输出系数； 系数小于0时，不输出加号； 幂指数为1时,不输出幂指数； 幂指数为0时，只输出系数；开始的思路是对幂指数为0或1时的输出单独处理，但没有考虑到系数为1或-1的情况…导致没有一个测试点通过… 错误代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package 零基础学Java语言_翁恺;import java.util.Scanner;public class Fifth_Week&#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner in = new Scanner(System.in ); int[] a = new int[101]; int m = 0, n = 0; boolean flag = false; for(int i=0;i&lt;100;i++) a[i]=0; int m_max = 0; // 读入第一个多项式 do &#123; m = in.nextInt(); n = in.nextInt(); a[m] = n; if (m &gt; m_max) m_max = m; &#125;while(m!=0); // 读入第二个多项式 do &#123; m = in.nextInt(); n = in.nextInt(); a[m] += n; if (m &gt; m_max) m_max = m; &#125;while (m!=0); for (int j = m_max; j &gt; 1; j--) &#123; if (a[j] != 0) &#123; if (flag&amp;&amp;a[j]&gt;0) System.out.print("+"); if(a[j]==-1) System.out.print("-"); flag = true; System.out.print(a[j] + "x" + j); &#125; else continue; &#125; // 处理幂次为1的情况 if (a[1] != 0) &#123; if (flag&amp;&amp;a[1]&gt;0) System.out.print("+"); if(a[1]==-1) System.out.print("-"); System.out.print(a[1] + "x"); flag = true; &#125; // 处理幂次为0的情况 if (a[0] != 0) &#123; if (flag) System.out.print("+"); System.out.print(a[0]); &#125; // System.out.println(); in.close(); &#125;&#125; 补充：&#160;&#160;&#160;&#160;把源码发到了MOOC的讨论区，在热心网友的帮助下，终于找到了有一个测试点没通过的原因…..&#160;&#160;&#160;&#160;对于系数全部为0的情况，程序会无输出…..&#160;&#160;&#160;&#160;例：对于下列这组数据 6 32 50 36 -32 -50 -3在in.close()前面加上这一段就好了if(!flag)System.out.print(&quot;0&quot;);]]></content>
      <categories>
        <category>零基础学Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-复杂度2 Maximum Subsequence Sum（25 分）]]></title>
    <url>%2F41173.html</url>
    <content type="text"><![CDATA[Problem:Given a sequence of KK integers {N1,N2,…,NK}. A continuous subsequence is defined to be {Ni,Ni+1,…,Nj} where 1≤i≤j≤K1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification:Each input file contains one test case. Each case occupies two lines. The first line contains a positive integerK(≤10000). The second line contains K numbers, separated by a space. Output Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.output the first and the last numbers of the whole sequence. Sample Input:10-10 1 2 3 4 -5 -23 3 7 -21 Sample Output:10 1 4 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll Start, End;int a[1000006];ll n;int MaxSubseqSum2( int A[], int N )&#123; int ThisSum, MaxSum = -0xffff; int i, j; for( i = 0; i &lt; N; i++ ) /* i是子列左端位置 */ &#123; ThisSum = 0; /* ThisSum是从A[i]到A[j]的子列和 */ for( j = i; j &lt; N; j++ ) /* j是子列右端位置 */ &#123; ThisSum += A[j]; /*对于相同的i，不同的j，只要在j-1次循环的基础上累加1项即可*/ if( ThisSum &gt; MaxSum ) /* 如果刚得到的这个子列和更大 */ &#123; MaxSum = ThisSum; /* 则更新结果 */ Start = A[i]; End = A[j]; &#125; &#125; /* j循环结束 */ &#125; /* i循环结束 */ return MaxSum;&#125;void input()&#123; cin &gt;&gt; n; for(ll i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125;&#125;void output()&#123; int temp = MaxSubseqSum2(a, n); if(temp &lt; 0) cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; a[0] &lt;&lt; " " &lt;&lt; a[n - 1] &lt;&lt; endl; else cout &lt;&lt; MaxSubseqSum2(a, n) &lt;&lt; " " &lt;&lt; Start &lt;&lt; " " &lt;&lt; End &lt;&lt; endl;&#125;int main()&#123; cin.sync_with_stdio(false); input(); output(); return 0;&#125; 两重循环遍历，算法复杂度为O（N^2）；第一次提交有部分测试点没通过，其原因是对最大和小于0时的情况没处理好。]]></content>
      <categories>
        <category>数据结构_陈越、何钦铭</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四周编程题_实现一个表达MP3的媒体类型]]></title>
    <url>%2F46392.html</url>
    <content type="text"><![CDATA[题目：本周我们介绍了以继承方式实现的媒体资料库，在课程代码实现的基础上，请实现一个表达MP3的媒体类型，能和CD、DVD一样存放进这个Database。请提交这个MP3类的代码。如果你认为为了能存放MP3，需要修改Item和Database，也请一并提交Item和Database的代码。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package 面向对象程序设计_Java语言_翁恺;import java.util.ArrayList;class Item&#123; private String title; private int playTime; private boolean gotIt = false; private String comment; public Item(String title, int playTime, boolean gotIt, String comment) &#123; this.title = title; this.playTime = playTime; this.gotIt = gotIt; this.comment = comment; &#125; public void print() &#123; System.out.print("title:"+title+";"+"playTime:"+playTime+";"+"gotIt:"+gotIt+";"+"comment:"+comment+";"); &#125;&#125;class Mp3 extends Item&#123; private String artist; private int numofTracks; public Mp3(String title, int playTime, boolean gotIt, String comment,String artist,int numofTracks) &#123; super(title, playTime, gotIt, comment); this.artist=artist; this.numofTracks=numofTracks; &#125; @Override public void print() &#123; System.out.print("Mp3:&#123;"); super.print(); System.out.println("artist:"+artist+";"+"numofTracks:"+numofTracks+"&#125;"); &#125; &#125;public class Database&#123; private ArrayList&lt;Item&gt; list=new ArrayList&lt;Item&gt;(); public void add(Item item) &#123; list.add(item); &#125; public void list() &#123; for(Item item:list) item.print(); &#125; public static void main(String[] args) &#123; Database db=new Database(); db.add(new Mp3("A", 60, true, "good", "John", 20)); db.add(new Mp3("B", 80, true, "vrey good", "Tom", 10)); db.list(); &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>面向对象程序设计_Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三周编程题_查找里程]]></title>
    <url>%2F25475.html</url>
    <content type="text"><![CDATA[题目内容：下图为国内主要城市之间的公路里程： 你的程序要读入这样的一张表，然后，根据输入的两个城市的名称，给出这两个城市之间的里程。 注意：任何两个城市之间的里程都已经给出，不需要计算经第三地中转。注意：你并不需要去录入上图的数据，数据是在程序输入中给的。 输入格式:首先，你会读到若干个城市的名字。每个名字都只是一个英文单词，中间不含空格或其他符号。当读到名字为“###”（三个#号）时，表示城市名字输入结束，###并不是一个城市的名字。如果记读到的城市名字的数量为n。然后，你会读到nxn的一个整数矩阵。第一行的每一个数字，表示上述城市名单中第一个城市依次到另一个城市之间的里程。表中同一个城市之间的里程为0。最后，你会读到两个城市的名字。 输出格式：输出这两个城市之间的距离。 输入样例：Hagzou Hugzou Jigxng ###0 1108 7081108 0 994708 994 0Hagzou Jigxng 输出样例：708 时间限制：500ms内存限制：32000kb 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package 面向对象程序设计_Java语言_翁恺;import java.util.ArrayList;import java.util.HashMap;import java.util.Scanner;public class Third_Week&#123; private ArrayList&lt;String&gt; city = new ArrayList&lt;String&gt;(); private HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt; distince = new HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt;(); private static Scanner in = new Scanner(System.in); // 输入城市名及距离 public void input() &#123;// Scanner in = new Scanner(System.in); String temp; // 读入城市名 while (true) &#123; temp = in.next(); if (temp.equals("###") == true) break; city.add(temp); &#125; // 读入距离 for (int i = 0; i &lt; city.size(); i++) &#123; HashMap&lt;String, Integer&gt; temp_hashmap = new HashMap&lt;String, Integer&gt;(); for (int j = 0; j &lt; city.size(); j++) &#123; int dis = in.nextInt(); temp_hashmap.put(city.get(j), dis); &#125; distince.put(city.get(i), temp_hashmap); &#125;// in.close(); &#125; // 查找两个城市间的距离 public int search(String start, String end) &#123; int dis = 0; dis = distince.get(start).get(end); return dis; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Third_Week dis = new Third_Week();// Scanner in = new Scanner(System.in); dis.input(); String start = in.next(); String end = in.next(); System.out.println(dis.search(start, end)); in.close(); &#125;&#125; 小结：题目中给的样例有问题，有的地方多了几个空格，导致在本机测样例的时候，一直无输出，调试了半天。手打了样例之后，发现要查询的两个城市的名字无法读入，怀疑是scanner关闭了两次的问题，注释掉input()方法中的in.close()，果然。。。但是又有个warning，提示input()方法中的in没有关闭。强迫症，把scanner写成全局的，完美解决。开始没读清题意，以为要查询多组城市间的距离，查了下Java中读到末尾的方法，学会了hasnext()等方法。链接：java中关于判断文本文件读到文件尾链接：java使用两个scanner，关闭输入流]]></content>
      <categories>
        <category>面向对象程序设计_Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三周讨论区_学生成绩的数据结构]]></title>
    <url>%2F13223.html</url>
    <content type="text"><![CDATA[题目：如果要写程序表达一个班级的很多个学生的很多门课的成绩，应该如何表达这些数据？ 如果我们希望通过学生的姓名，可以找到他的所有的成绩，而每一门课的成绩，是由课程名称和分数构成的。 而如果我们还希望这个程序能找出某一门课的全部学生的成绩应该怎样做呢？ 注意，并非所有的学生都参加了所有的课程。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package test;import java.util.HashMap;public class Student_Grade&#123; private HashMap&lt;String, HashMap&lt;String, Double&gt;&gt; studentInfo = new HashMap&lt;String, HashMap&lt;String, Double&gt;&gt;(); // 通过姓名添加成绩 public void add(String name, String course, double grade) &#123; if (studentInfo.containsKey(name)) &#123; studentInfo.get(name).put(course, grade); &#125; else &#123; HashMap&lt;String, Double&gt; temp = new HashMap&lt;String, Double&gt;(); temp.put(course, grade); studentInfo.put(name, temp); &#125; &#125; // 通过姓名找到这名学生的所有成绩 public String getScore_name(String name) &#123; HashMap&lt;String, Double&gt; temp = new HashMap&lt;String, Double&gt;(); for (String k : studentInfo.keySet()) &#123; if (k == name) &#123; temp = studentInfo.get(name); break; &#125; &#125; return name+" "+temp.toString(); &#125; // 通过课程名找到这一门课的全部学生的成绩 public String getScore_subject(String subject) &#123; HashMap&lt;String, Double&gt; temp = new HashMap&lt;String, Double&gt;(); for (String k : studentInfo.keySet()) &#123; if (studentInfo.get(k).containsKey(subject)) &#123; temp.put(k, studentInfo.get(k).get(subject)); &#125; &#125; return subject+":"+temp.toString(); &#125; // 重载toString()方法 public String toString() &#123; String temp=""; for(String k:studentInfo.keySet()) temp+=(k+":"+studentInfo.get(k).toString()+"\n"); return temp; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Student_Grade student = new Student_Grade(); student.add("张三", "Java", 60.0); student.add("张三", "C++", 70.0); student.add("李四", "C++", 80.0); student.add("王五", "C++", 90.2); System.out.println(student.getScore_name("张三")); System.out.println(student.getScore_subject("C++")); System.out.println(student); &#125;&#125; 运行结果: 总结：起初，两个查询的方法如下所示，返回值是一个Hasmap&lt;String,Doubole&gt;。 后来在为Student_Grade写toString（）方法以便输出所有学生的所有成绩时，想到可以在两个查询的方法中临时建立一个String，调用toString()方法，赋值给它，并对该字符串进行处理，返回一个字符串。使得输出有”姓名“和”课程名“，信息更完整。（强迫症）12345678910111213141516171819202122232425262728// 通过姓名找到这名学生的所有成绩public HashMap&lt;String, Double&gt; getScore_name(String name)&#123; HashMap&lt;String, Double&gt; temp = new HashMap&lt;String, Double&gt;(); for (String k : studentInfo.keySet()) &#123; if (k == name) &#123; temp = studentInfo.get(name); break; &#125; &#125; return temp;&#125;// 通过课程名找到这一门课的全部学生的成绩public HashMap&lt;String, Double&gt; getScore_subject(String subject)&#123; HashMap&lt;String, Double&gt; temp = new HashMap&lt;String, Double&gt;(); for (String k : studentInfo.keySet()) &#123; if (studentInfo.get(k).containsKey(subject)) &#123; temp.put(k, studentInfo.get(k).get(subject)); &#125; &#125; return temp;&#125;]]></content>
      <categories>
        <category>面向对象程序设计_Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二周编程题_有秒计时的数字时钟]]></title>
    <url>%2F2173.html</url>
    <content type="text"><![CDATA[题目内容：&#160; &#160; &#160; &#160;这一周的编程题是需要你在课程所给的时钟程序的基础上修改而成。但是我们并不直接给你时钟程序的代码，请根据视频自己输入时钟程序的Display和Clock类的代码，然后来做这个题目。&#160; &#160; &#160; &#160;我们需要给时钟程序加上一个表示秒的Display，然后为Clock增加以下public的成员函数： public Clock(int hour, int minute, int second);&#160; &#160; &#160; &#160;用hour, minute和second初始化时间。public void tick();&#160; &#160; &#160; &#160;“嘀嗒”一下，时间走1秒。public String toString();&#160; &#160; &#160; &#160;返回一个String的值，以“hh:mm:ss“的形式表示当前时间。这里每个数值都占据两位，不足两位时补0。如“00:01:22”。注意其中的冒号是西文的，不是中文的。 提示：String.format()可以用和printf一样的方式来格式化一个字符串。 另外写一个Main类，它的main函数为下面的样子，注意，必须原封不动地作为Main的main函数： public static void main(String[] args) {java.util.Scanner in = new java.util.Scanner(System.in);Clock clock = new Clock(in.nextInt(), in.nextInt(), in.nextInt());clock.tick();System.out.println(clock);in.close();} 注意！在提交的时候，把Main、Clock和Display三个类的代码合并在一起，其中Main类是public的，而Clock和Display类是没有修饰符的。另外，千万注意第一行不能有package语句。 输入格式:采用给定的main函数无需考虑输入输出。 输出格式：采用给定的main函数无需考虑输入输出。 输入样例：采用给定的main函数无需考虑输入输出。 输出样例：采用给定的main函数无需考虑输入输出。时间限制：500ms内存限制：32000kb 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package 面向对象程序设计_Java语言_翁恺;public class Second_Week&#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub java.util.Scanner in = new java.util.Scanner(System.in); Clock clock = new Clock(in.nextInt(), in.nextInt(), in.nextInt()); clock.tick(); System.out.println(clock); in.close(); &#125;&#125;class Display&#123; private int limit = 0; private int value = 0; public Display(int limit) &#123; // TODO Auto-generated constructor stub this.limit = limit; &#125; public void setvalue(int value) &#123; this.value = value; &#125; public boolean increase() &#123; boolean temp = false; value++; if (value == limit) &#123; value = 0; temp = true; &#125; return temp; &#125; public int getvalue() &#123; return value; &#125;&#125;class Clock&#123; private Display hour = new Display(24); private Display minute = new Display(60); private Display second = new Display(60); public Clock(int hour, int minute, int second) &#123; this.hour.setvalue(hour); this.minute.setvalue(minute); this.second.setvalue(second); &#125; public String toString() &#123; return String.format("%02d:%02d:%02d", hour.getvalue(), minute.getvalue(), second.getvalue()); &#125; public void tick() &#123; if (this.second.increase() == true) &#123; if (this.minute.increase() == true) this.hour.increase(); &#125;// System.out.println(toString()); &#125;&#125; 没写toString()方法时，输出为：面向对象程序设计Java语言翁恺.Clock@7d4991ad 学习心得：toString（）方法是Object类的一个实例方法，所有的Java类都是Object类的子类，故所有的Java类都有toString（）方法。除此外，所有的Java类的对象都可以和字符串进行连接运算，当Java类对象和字符串进行连接运算时，系统自动调用Java对象toString（）方法的返回值和字符串进行连接操作，如：&#160; &#160; &#160; &#160;String str=p+“123”；&#160; &#160; &#160; &#160;String str=p.toString()+”123”;toString()方法是一个非常特殊的方法，是一个“自我描述”方法，该方法通常用于实现当程序员直接打印该对象时，系统将会输出该对象的“自我描述”信息，用以告诉外界该对象具有的状态信息。Object类提供的toString()方法总是返回该对象实现类的”类名+@+hashCode”值，这个返回值不能真正实现“自我描述”功能，因此我们可以重写object的toString()方法。]]></content>
      <categories>
        <category>面向对象程序设计_Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一周编程题_分数]]></title>
    <url>%2F47907.html</url>
    <content type="text"><![CDATA[题目内容：设计一个表示分数的类Fraction。这个类用两个int类型的变量分别表示分子和分母。 这个类的构造函数是：Fraction(int a, int b)&#160; &#160; &#160; &#160;构造一个a/b的分数。 这个类要提供以下的功能：double toDouble();&#160; &#160; &#160; &#160;将分数转换doubleFraction plus(Fraction r);&#160; &#160; &#160; &#160;将自己的分数和r的分数相加，产生一个新的Fraction的对象。注意小学四年级学过两个分数如何相加的哈。Fraction multiply(Fraction r);&#160; &#160; &#160; &#160;将自己的分数和r的分数相乘，产生一个新的Fraction的对象。void print();&#160; &#160; &#160; &#160;将自己以“分子/分母”的形式输出到标准输出，并带有回车换行。如果分数是1/1，应该输出1。当分子大于分母时，不需要提出整数部分，即31/30是一个正确的输出。 注意，在创建和做完运算后应该化简分数为最简形式。如2/4应该被化简为1/2。 你写的类要和以下的代码放在一起，并请勿修改这个代码： import java.util.Scanner;public class Main {public static void main(String[] args) {Scanner in = new Scanner(System.in);Fraction a = new Fraction(in.nextInt(), in.nextInt());Fraction b = new Fraction(in.nextInt(),in.nextInt());a.print();b.print();a.plus(b).print();a.multiply(b).plus(new Fraction(5,6)).print();a.print();b.print();in.close();}} 注意，你的类的定义应该这样开始： class Fraction { 也就是说，在你的类的class前面不要有public。 输入格式:程序运行时会得到四个数字，分别构成两个分数，依次是分子和分母。 输出格式：输出一些算式。这些输入和输出都是由Main类的代码完成的，你的代码不要做输入和输出。 输入样例：2 4 1 3 输出样例：1/21/35/611/21/3 时间限制：500ms内存限制：32000kb 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package 面向对象程序设计_Java语言_翁恺;import java.util.Scanner;public class First_Week&#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner in = new Scanner(System.in); Fraction a = new Fraction(in.nextInt(), in.nextInt()); Fraction b = new Fraction(in.nextInt(), in.nextInt()); a.print(); b.print(); a.plus(b).print(); a.multiply(b).plus(new Fraction(5, 6)).print(); a.print(); b.print(); in.close(); &#125;&#125;class Fraction&#123; private int a; private int b; public Fraction(int a, int b) &#123; // TODO Auto-generated constructor stub this.a = a; this.b = b; &#125; public Fraction plus(Fraction r) &#123; int aa = a * r.b + r.a * b; int bb = b * r.b; Fraction temp = new Fraction(aa, bb); return temp; &#125; public Fraction multiply(Fraction r) &#123; int aa = a * r.a; int bb = b * r.b; Fraction temp = new Fraction(aa, bb); return temp; &#125; public double toDouble() &#123; return a * 1.0 / b; &#125; public void print() &#123; int x = a, y = b, r = 1; while (y != 0) &#123; r = x % y; x = y; y = r; &#125; a /= x; b /= x; if (a == b) System.out.println(1); else System.out.println(a + "/" + b); &#125;&#125; 初学Java，按照C++中的习惯，开始的时候果断写成了下图这样/捂脸~好菜~~1234567public Fraction plus(Fraction r)&#123; int aa = a * r.b + r.a * b; int bb = b * r.b; Fraction temp(aa, bb); return temp;&#125;]]></content>
      <categories>
        <category>面向对象程序设计_Java语言_翁恺</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017百度之星资格赛 1003 度度熊与邪恶大魔王（完全背包）]]></title>
    <url>%2F53776.html</url>
    <content type="text"><![CDATA[度度熊与邪恶大魔王Accepts: 2016Submissions: 12307Time Limit: 2000/1000 MS (Java/Others)Memory Limit: 32768/32768 K (Java/Others)传送门: bestcoder Problem Description度度熊为了拯救可爱的公主，于是与邪恶大魔王战斗起来。邪恶大魔王的麾下有n个怪兽，每个怪兽有a[i]的生命值，以及b[i]的防御力。度度熊一共拥有m种攻击方式，第i种攻击方式，需要消耗k[i]的晶石，造成p[i]点伤害。当然，如果度度熊使用第i个技能打在第j个怪兽上面的话，会使得第j个怪兽的生命值减少p[i]-b[j]，当然如果伤害小于防御，那么攻击就不会奏效。如果怪兽的生命值降为0或以下，那么怪兽就会被消灭。当然每个技能都可以使用无限次。请问度度熊最少携带多少晶石，就可以消灭所有的怪兽。 Input本题包含若干组测试数据。第一行两个整数n，m,表示有n个怪兽，m种技能。接下来n行，每行两个整数，a[i],b[i]，分别表示怪兽的生命值和防御力。再接下来m行，每行两个整数k[i]和p[i]，分别表示技能的消耗晶石数目和技能的伤害值。数据范围: 1&lt;=n&lt;=1000001&lt;=m&lt;=10001&lt;=a[i]&lt;=10000&lt;=b[i]&lt;=100&lt;=k[i]&lt;=1000000&lt;=p[i]&lt;=1000## Output对于每组测试数据，输出最小的晶石消耗数量，如果不能击败所有的怪兽，输出-1## Sample Input1 23 57 106 81 23 510 78 Sample Output816 Aceppted代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/*Problem:度度熊与邪恶大魔王Author:QiZhaoData:2017-08-05Description:DP，完全背包Copyright 2017 QiZhao. All rights reserved.*/#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1020;const ll INF=0x3f3f3f3f;ll num[maxn][12];//防御值为j，生命值为i的怪物的个数ll dp[1020][15];//对于生命值为i，防御值为j的怪物所消耗的最小水晶数struct skill&#123; ll hit; ll price;&#125; a[maxn];ll best[maxn];//攻击力为i时，消耗的最少水晶数。ll min(ll a,ll b)&#123; if(a&gt;b) return b; else return a; &#125; void complete_packet(int k, int p)//p为攻击力，k为消耗水晶数&#123; for (int b = 0; b &lt;= 10; ++b) &#123; if (b &gt;= p) &#123; continue; &#125; else &#123; int d = p - b; //血量小于攻击 for (int a = 1; a &lt;= d; ++a) &#123; dp[a][b] = min(dp[a][b], k); &#125; //血量大于攻击 for (int a = d + 1; a &lt;= 1000; ++a) &#123; dp[a][b] = min(dp[a][b], dp[a - d][b] + k); &#125; &#125; &#125;&#125;int main()&#123; cin.sync_with_stdio(false); ll n, m; ll x, y; ll /*max_hp = -0xffff,*/ max_def = -INF, max_hit = -INF; while(cin &gt;&gt; n &gt;&gt; m) &#123; max_def = -INF, max_hit = -INF; memset(num, 0, sizeof(num)); memset(a, 0, sizeof(a)); memset(best, -1, sizeof(best)); memset(dp, 0, sizeof(dp)); for(ll i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; num[x][y]++; //if(x &gt;= max_hp) //max_hp = x; if(y &gt;= max_def) max_def = y; &#125; ll flag = 0; for(ll i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x &gt;&gt; y; if(best[y] == -1) &#123; a[flag].hit = y; a[flag].price = x; best[y] = x; if(a[flag].hit &gt; max_hit) max_hit = a[flag].hit; flag++; &#125; else &#123; if(x &lt; best[y]) best[y] = x; &#125; &#125; ll ans = 0; ll temp = 0; //记录已处理怪物个数，优化时间 if(max_def &gt;= max_hit) cout &lt;&lt; "-1" &lt;&lt; endl; else &#123; for (int i = 0; i &lt;= 1010; ++i)//初始化DP &#123; for (int j = 0; j &lt;= 10; ++j) &#123; if (i == 0) &#123; dp[i][j] = 0; &#125; else &#123; dp[i][j] = INF; &#125; &#125; &#125; for(int i=0;i&lt;flag;i++) complete_packet(best[a[i].hit],a[i].hit); for(ll i = 0; i &lt; 1002; i++) &#123; if(temp == n)//优化时间 break; for(ll j = 0; j &lt; 12; j++) &#123; if(num[i][j] != 0) &#123; temp += num[i][j]; ans += dp[i][j]*num[i][j]; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>百度之星</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
</search>
